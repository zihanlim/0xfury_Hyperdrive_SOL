{
  "version": 3,
  "sources": ["../../react-pin-input-hook/src/index.ts"],
  "sourcesContent": ["import * as React from 'react'\n\ntype PinInputValues = string[]\n\nexport interface PinInputActions {\n  /**\n   * Imperative function call to lose focus.\n   */\n  blur: () => void\n  /**\n   * Imperative function call to set focus on the first empty field. In the case when `error: true`,\n   * the focus is set to the first empty field. The argument takes an optional parameter in the form\n   * of a number (ordinal index), which will set the focus on a specific field.\n   * @param {number} index\n   */\n  focus: (index?: number) => void\n}\n\nexport interface UsePinInputProps {\n  /**\n   * Field values. If no values are passed, the default value defined in `defaultValues` is used.\n   */\n  values?: PinInputValues\n  /**\n   * The function is called every time the value changes.\n   * @param {PinInputValues} values\n   */\n  onChange?: (values: PinInputValues) => void\n  /**\n   * The function is called when all fields are filled in.\n   * @param {string} value\n   */\n  onComplete?: (value: string) => void\n  /**\n   * A reference to imperative actions.\n   */\n  actionRef?: React.Ref<PinInputActions>\n  /**\n   * Automatic focus setting at the first mount, is set to the first field.\n   */\n  autoFocus?: boolean\n  /**\n   * In the case when the component is unmanaged, default values are set, where the number of values\n   * in the array is equal to the number of fields.\n   */\n  defaultValues?: PinInputValues\n  /**\n   * Changes the type of keyboard display on mobile devices.\n   */\n  type?: 'numeric' | 'alphanumeric'\n  /**\n   * If `true', then the attribute `autocomplete=\"one-time-code\"` is added, otherwise\n   * `autocomplete=\"off\"`.\n   */\n  otp?: boolean\n  /**\n   * Placeholder for the `input` element.\n   */\n  placeholder?: string\n  /**\n   * If `true`, the transmission of event handlers `onChange`, `onBlur`, `onFocus` and `onKeyDown`\n   * in the parameters of each field is prevented.\n   */\n  disabled?: boolean\n  /**\n   * If `true`, then the attribute `type=\"password\"` is set, otherwise `type=\"text\"`.\n   */\n  mask?: boolean\n  /**\n   * If `true`, then the focus behavior on the fields changes.\n   */\n  error?: boolean\n}\n\nexport type PinInputClearOptions = {\n  /**\n   * If `true', then the focus is set on the first field, otherwise after clearing it disappears.\n   */\n  focus?: boolean\n}\n\nexport interface PinInputFieldProps {\n  /**\n   * Returns a callback function to register the field.\n   */\n  ref: React.RefCallback<HTMLInputElement>\n  /**\n   * Returns the value of the field.\n   */\n  value: string\n  /**\n   * Returns the value passed by the `disabled` parameter.\n   */\n  disabled: boolean\n  /**\n   * Returns either `one-time-code` if the parameter `otp: true` was passed, otherwise `off`.\n   */\n  autoComplete: 'one-time-code' | 'off'\n  /**\n   * Returns either `text` if the parameter `type: 'alphanumeric'` was passed, otherwise `numeric`.\n   */\n  inputMode: 'text' | 'numeric'\n  /**\n   * Returns either `password` if the `mask: true` parameter was passed, or `text`.\n   */\n  type: 'text' | 'password'\n  /**\n   * Returns the value passed by the `placeholder` parameter if there are no focused fields.\n   */\n  placeholder: string\n  /**\n   * Returns the handler for the focus loss event if `disabled: false`.\n   * @param {React.FocusEvent<HTMLInputElement>} event\n   */\n  onBlur?: React.FocusEventHandler<HTMLInputElement>\n  /**\n   * Returns the handler for the focus appearance event if `disabled: false`.\n   * @param {React.FocusEvent<HTMLInputElement>} event\n   */\n  onFocus?: React.FocusEventHandler<HTMLInputElement>\n  /**\n   * Returns a handler for the field change event if `disabled: false`.\n   * @param {React.ChangeEvent<HTMLInputElement>} event\n   */\n  onChange?: React.ChangeEventHandler<HTMLInputElement>\n  /**\n   * Returns a handler for the keystroke event if `disabled: false`.\n   * @param {React.KeyboardEvent<HTMLInputElement>} event\n   */\n  onKeyDown?: React.KeyboardEventHandler<HTMLInputElement>\n}\n\nexport function usePinInput({\n  values: valuesProp,\n  onChange: onChangeProp,\n  onComplete,\n  actionRef,\n  autoFocus = false,\n  defaultValues = Array(6).fill(''),\n  type = 'numeric',\n  otp = false,\n  placeholder = 'â—‹',\n  disabled = false,\n  mask = false,\n  error = false,\n}: UsePinInputProps = {}) {\n  const [valuesState, setValues] = React.useState(defaultValues)\n  const [focusedIndex, setFocusedIndex] = React.useState(-1)\n\n  const isControlled = valuesProp !== undefined\n  const values = (isControlled ? valuesProp : valuesState) as PinInputValues\n  const isTypeAlphanumeric = type === 'alphanumeric'\n\n  const fieldRefs = React.useRef<HTMLInputElement[]>(Array(values.length).fill(null))\n\n  const setFocus = React.useCallback((index = 0) => {\n    fieldRefs.current[index]?.focus()\n  }, [])\n\n  React.useEffect(() => {\n    if (autoFocus) {\n      setFocus()\n    }\n  }, [autoFocus, setFocus])\n\n  const setBlur = React.useCallback(() => {\n    fieldRefs.current[focusedIndex]?.blur()\n  }, [focusedIndex])\n\n  React.useImperativeHandle(\n    actionRef,\n    () => ({\n      focus: (index = 0) => {\n        const emptyFieldIndex = values.findIndex((v) => !v)\n\n        setFocus(error ? (emptyFieldIndex === -1 ? index : emptyFieldIndex) : index)\n      },\n      blur: setBlur,\n    }),\n    [setBlur, setFocus, values, error]\n  )\n\n  const setFieldRef = React.useCallback(\n    (index: number) => (ref: HTMLInputElement) => {\n      fieldRefs.current[index] = ref\n    },\n    []\n  )\n\n  const updateValues = React.useCallback(\n    (values: PinInputValues) => {\n      if (!isControlled) {\n        setValues(values)\n      }\n\n      onChangeProp?.(values)\n    },\n    [isControlled, setValues, onChangeProp]\n  )\n\n  const onChange = React.useCallback(\n    (index: number): React.ChangeEventHandler<HTMLInputElement> =>\n      (event) => {\n        let { value } = event.target\n\n        value = value.trim()\n\n        const regexType = isTypeAlphanumeric ? /^[a-z\\d]*$/i : /^\\d*$/\n\n        if (!regexType.test(value)) {\n          return\n        }\n\n        if (isTypeAlphanumeric) {\n          value = value.toUpperCase()\n        }\n\n        if (value.length > 2) {\n          if (value.length === values.length) {\n            updateValues(value.split(''))\n            onComplete?.(value)\n          }\n\n          return\n        }\n\n        if (value.length === 2) {\n          const currentValue = values[index]\n\n          if (currentValue === value[0]) {\n            value = value[1]\n          } else if (currentValue === value[1]) {\n            value = value[0]\n          } else {\n            return\n          }\n        }\n\n        const nextValues = values.slice()\n        nextValues[index] = value\n        updateValues(nextValues)\n\n        if (value) {\n          if (!nextValues.includes('')) {\n            onComplete?.(nextValues.join(''))\n          }\n\n          if (index !== values.length - 1) {\n            if (error) {\n              const emptyFieldIndex = nextValues.findIndex((v) => !v)\n\n              if (emptyFieldIndex !== -1) {\n                setFocus(emptyFieldIndex)\n              }\n            } else {\n              setFocus(index + 1)\n            }\n          }\n        }\n      },\n    [isTypeAlphanumeric, values, updateValues, onComplete, setFocus, error]\n  )\n\n  const onKeyDown = React.useCallback(\n    (index: number): React.KeyboardEventHandler<HTMLInputElement> =>\n      (event) => {\n        if (event.key === 'Backspace' && !values[index] && index) {\n          setFocus(index - 1)\n        }\n      },\n    [values, setFocus]\n  )\n\n  const clear = React.useCallback(\n    ({ focus = false }: PinInputClearOptions = {}) => {\n      updateValues(Array(values.length).fill(''))\n\n      if (focus) {\n        setFocus()\n      } else {\n        setBlur()\n      }\n    },\n    [updateValues, values, setFocus, setBlur]\n  )\n\n  const onFocus = React.useCallback(\n    (index: number) => () => {\n      setFocusedIndex(index)\n    },\n    []\n  )\n\n  const onBlur = React.useCallback(() => {\n    setFocusedIndex(-1)\n  }, [])\n\n  const hasFocus = focusedIndex !== -1\n\n  const fields: PinInputFieldProps[] = values.map((value: string, index: number) => ({\n    ref: setFieldRef(index),\n    value,\n    disabled,\n    autoComplete: otp ? 'one-time-code' : 'off',\n    inputMode: isTypeAlphanumeric ? 'text' : 'numeric',\n    type: mask ? 'password' : 'text',\n    placeholder: hasFocus ? '' : placeholder,\n    ...(!disabled && {\n      onBlur,\n      onFocus: onFocus(index),\n      onChange: onChange(index),\n      onKeyDown: onKeyDown(index),\n    }),\n  }))\n\n  return { fields, clear, isFocused: hasFocus }\n}\n\nexport type UsePinInputReturn = ReturnType<typeof usePinInput>\n"],
  "mappings": "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",
  "names": ["usePinInput", "_temp", "_ref", "valuesProp", "values", "onChangeProp", "onChange", "onComplete", "actionRef", "autoFocus", "_ref$autoFocus", "defaultValues", "_ref$defaultValues", "Array", "fill", "type", "_ref$type", "_ref$otp", "otp", "placeholder", "_ref$placeholder", "_ref$disabled", "disabled", "mask", "_ref$mask", "_ref$error", "error", "_React$useState", "useState", "valuesState", "setValues", "focusedIndex", "setFocusedIndex", "_React$useState2", "isControlled", "isTypeAlphanumeric", "fieldRefs", "useRef", "length", "setFocus", "useCallback", "index", "current", "_fieldRefs$current$in", "focus", "React", "useEffect", "setBlur", "_fieldRefs$current$fo", "blur", "useImperativeHandle", "n", "findIndex", "v", "emptyFieldIndex", "setFieldRef", "ref", "updateValues", "event", "value", "target", "trim", "test", "toUpperCase", "split", "currentValue", "nextValues", "slice", "includes", "join", "l", "onKeyDown", "key", "clear", "_temp2", "_ref2$focus", "onBlur", "hasFocus", "fields", "map", "autoComplete", "inputMode", "onFocus", "isFocused"]
}
