import {
  require_src
} from "./chunk-QZGUHWVJ.js";
import {
  init_lib7 as init_lib2,
  lib_exports7 as lib_exports2
} from "./chunk-SI3342XM.js";
import {
  init_lib4 as init_lib,
  lib_exports3 as lib_exports
} from "./chunk-3KD3TUYK.js";
import {
  __commonJS,
  __toCommonJS,
  init_buffer,
  init_process
} from "./chunk-3V4EFXE5.js";

// node_modules/@biconomy/paymaster/dist/src/interfaces/IPaymaster.js
var require_IPaymaster = __commonJS({
  "node_modules/@biconomy/paymaster/dist/src/interfaces/IPaymaster.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@biconomy/paymaster/dist/src/interfaces/IHybridPaymaster.js
var require_IHybridPaymaster = __commonJS({
  "node_modules/@biconomy/paymaster/dist/src/interfaces/IHybridPaymaster.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@biconomy/paymaster/dist/src/utils/Types.js
var require_Types = __commonJS({
  "node_modules/@biconomy/paymaster/dist/src/utils/Types.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PaymasterMode = void 0;
    var PaymasterMode;
    (function(PaymasterMode2) {
      PaymasterMode2["ERC20"] = "ERC20";
      PaymasterMode2["SPONSORED"] = "SPONSORED";
    })(PaymasterMode = exports.PaymasterMode || (exports.PaymasterMode = {}));
  }
});

// node_modules/@biconomy/paymaster/dist/src/constants.js
var require_constants = __commonJS({
  "node_modules/@biconomy/paymaster/dist/src/constants.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ERC20_ABI = exports.ENTRYPOINT_ADDRESS = void 0;
    exports.ENTRYPOINT_ADDRESS = "0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789";
    exports.ERC20_ABI = [
      "function transfer(address to, uint256 value) external returns (bool)",
      "function transferFrom(address from, address to, uint256 value) external returns (bool)",
      "function approve(address spender, uint256 value) external returns (bool)",
      "function allowance(address owner, address spender) external view returns (uint256)",
      "function balanceOf(address owner) external view returns (uint256)"
    ];
  }
});

// node_modules/@biconomy/paymaster/dist/src/BiconomyPaymaster.js
var require_BiconomyPaymaster = __commonJS({
  "node_modules/@biconomy/paymaster/dist/src/BiconomyPaymaster.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BiconomyPaymaster = void 0;
    var common_1 = require_src();
    var properties_1 = (init_lib(), __toCommonJS(lib_exports));
    var Types_1 = require_Types();
    var ethers_1 = (init_lib2(), __toCommonJS(lib_exports2));
    var constants_1 = require_constants();
    var defaultPaymasterConfig = {
      paymasterUrl: "",
      strictMode: true
      // Set your desired default value for strictMode here
    };
    var BiconomyPaymaster = class {
      constructor(config) {
        const mergedConfig = {
          ...defaultPaymasterConfig,
          ...config
        };
        this.paymasterConfig = mergedConfig;
      }
      /**
       * @dev Prepares the user operation by resolving properties and converting certain values to hexadecimal format.
       * @param userOp The partial user operation.
       * @returns A Promise that resolves to the prepared partial user operation.
       */
      async prepareUserOperation(userOp) {
        userOp = await (0, properties_1.resolveProperties)(userOp);
        userOp.nonce = ethers_1.BigNumber.from(userOp.nonce).toHexString();
        userOp.callGasLimit = ethers_1.BigNumber.from(userOp.callGasLimit).toString();
        userOp.verificationGasLimit = ethers_1.BigNumber.from(userOp.verificationGasLimit).toString();
        userOp.maxFeePerGas = ethers_1.BigNumber.from(userOp.maxFeePerGas).toHexString();
        userOp.maxPriorityFeePerGas = ethers_1.BigNumber.from(userOp.maxPriorityFeePerGas).toHexString();
        userOp.preVerificationGas = ethers_1.BigNumber.from(userOp.preVerificationGas).toString();
        userOp.signature = "0x";
        userOp.paymasterAndData = "0x";
        return userOp;
      }
      /**
       * @dev Builds a token approval transaction for the Biconomy token paymaster.
       * @param tokenPaymasterRequest The token paymaster request data. This will include information about chosen feeQuote, spender address and optional flag to provide maxApproval
       * @param provider Optional provider object.
       * @returns A Promise that resolves to the built transaction object.
       */
      async buildTokenApprovalTransaction(tokenPaymasterRequest, provider) {
        const feeTokenAddress = tokenPaymasterRequest.feeQuote.tokenAddress;
        common_1.Logger.log("erc20 fee token address ", feeTokenAddress);
        const spender = tokenPaymasterRequest.spender;
        common_1.Logger.log("spender address ", spender);
        common_1.Logger.log("provider object passed - is provider", provider === null || provider === void 0 ? void 0 : provider._isProvider);
        let requiredApproval = ethers_1.BigNumber.from(0).toString();
        if (tokenPaymasterRequest.maxApproval && tokenPaymasterRequest.maxApproval == true) {
          requiredApproval = ethers_1.ethers.constants.MaxUint256;
        } else {
          requiredApproval = Math.ceil(tokenPaymasterRequest.feeQuote.maxGasFee * Math.pow(10, tokenPaymasterRequest.feeQuote.decimal)).toString();
        }
        common_1.Logger.log("required approval for erc20 token ", requiredApproval);
        const erc20Interface = new ethers_1.ethers.utils.Interface(JSON.stringify(constants_1.ERC20_ABI));
        try {
          const data = erc20Interface.encodeFunctionData("approve", [spender, requiredApproval]);
          return {
            to: feeTokenAddress,
            value: ethers_1.ethers.BigNumber.from(0),
            data
          };
        } catch (error) {
          common_1.Logger.error("Error encoding function data:", error);
          throw new Error("Failed to encode function data");
        }
      }
      /**
       * @dev Retrieves paymaster fee quotes or data based on the provided user operation and paymaster service data.
       * @param userOp The partial user operation.
       * @param paymasterServiceData The paymaster service data containing token information and sponsorship details. Devs can send just the preferred token or array of token addresses in case of mode "ERC20" and sartAccountInfo in case of "sponsored" mode.
       * @returns A Promise that resolves to the fee quotes or data response.
       */
      async getPaymasterFeeQuotesOrData(userOp, paymasterServiceData) {
        var _a, _b, _c;
        try {
          userOp = await this.prepareUserOperation(userOp);
        } catch (err) {
          common_1.Logger.log("Error in prepareUserOperation ", err);
          throw err;
        }
        let mode = null;
        const calculateGasLimits = paymasterServiceData.calculateGasLimits ? paymasterServiceData.calculateGasLimits : false;
        common_1.Logger.log("calculateGasLimits is ", calculateGasLimits);
        let preferredToken = null;
        let feeTokensArray = [];
        let smartAccountInfo = {
          name: "BICONOMY",
          version: "1.0.0"
        };
        let webhookData = null;
        if (paymasterServiceData.mode) {
          common_1.Logger.log("Requested mode is ", paymasterServiceData.mode);
          mode = paymasterServiceData.mode;
        }
        preferredToken = (paymasterServiceData === null || paymasterServiceData === void 0 ? void 0 : paymasterServiceData.preferredToken) ? paymasterServiceData === null || paymasterServiceData === void 0 ? void 0 : paymasterServiceData.preferredToken : preferredToken;
        common_1.Logger.log("userop is ", userOp);
        feeTokensArray = ((_a = paymasterServiceData === null || paymasterServiceData === void 0 ? void 0 : paymasterServiceData.tokenList) === null || _a === void 0 ? void 0 : _a.length) !== 0 ? paymasterServiceData === null || paymasterServiceData === void 0 ? void 0 : paymasterServiceData.tokenList : feeTokensArray;
        webhookData = (_b = paymasterServiceData === null || paymasterServiceData === void 0 ? void 0 : paymasterServiceData.webhookData) !== null && _b !== void 0 ? _b : webhookData;
        smartAccountInfo = (_c = paymasterServiceData === null || paymasterServiceData === void 0 ? void 0 : paymasterServiceData.smartAccountInfo) !== null && _c !== void 0 ? _c : smartAccountInfo;
        try {
          const response = await (0, common_1.sendRequest)({
            url: `${this.paymasterConfig.paymasterUrl}`,
            method: common_1.HttpMethod.Post,
            body: {
              method: "pm_getFeeQuoteOrData",
              params: [
                userOp,
                {
                  ...mode !== null && { mode },
                  calculateGasLimits,
                  tokenInfo: {
                    tokenList: feeTokensArray,
                    ...preferredToken !== null && { preferredToken }
                  },
                  sponsorshipInfo: {
                    ...webhookData !== null && { webhookData },
                    smartAccountInfo
                  }
                }
              ],
              id: (0, common_1.getTimestampInSeconds)(),
              jsonrpc: "2.0"
            }
          });
          if (response && response.result) {
            common_1.Logger.log("feeInfo ", response.result);
            if (response.result.mode == Types_1.PaymasterMode.ERC20) {
              const feeQuotesResponse = response.result.feeQuotes;
              const paymasterAddress = response.result.paymasterAddress;
              return { feeQuotes: feeQuotesResponse, tokenPaymasterAddress: paymasterAddress };
            } else if (response.result.mode == Types_1.PaymasterMode.SPONSORED) {
              const paymasterAndData = response.result.paymasterAndData;
              const preVerificationGas = response.result.preVerificationGas;
              const verificationGasLimit = response.result.verificationGasLimit;
              const callGasLimit = response.result.callGasLimit;
              return {
                paymasterAndData,
                preVerificationGas,
                verificationGasLimit,
                callGasLimit
              };
            } else {
              const errorObject = {
                code: 417,
                message: "Expectation Failed: Invalid mode in Paymaster service response"
              };
              throw errorObject;
            }
          }
        } catch (error) {
          common_1.Logger.log(error.message);
          common_1.Logger.error("Failed to fetch Fee Quotes or Paymaster data - reason: ", JSON.stringify(error));
          if (!this.paymasterConfig.strictMode && paymasterServiceData.mode == Types_1.PaymasterMode.SPONSORED && ((error === null || error === void 0 ? void 0 : error.message.includes("Smart contract data not found")) || (error === null || error === void 0 ? void 0 : error.message.includes("No policies were set")))) {
            common_1.Logger.log(`Strict mode is ${this.paymasterConfig.strictMode}. sending paymasterAndData 0x`);
            return {
              paymasterAndData: "0x",
              // send below values same as userOp gasLimits
              preVerificationGas: userOp.preVerificationGas,
              verificationGasLimit: userOp.verificationGasLimit,
              callGasLimit: userOp.callGasLimit
            };
          }
          throw error;
        }
        throw new Error("Failed to fetch feeQuote or paymaster data");
      }
      /**
       * @dev Retrieves the paymaster and data based on the provided user operation and paymaster service data.
       * @param userOp The partial user operation.
       * @param paymasterServiceData Optional paymaster service data.
       * @returns A Promise that resolves to the paymaster and data string.
       */
      async getPaymasterAndData(userOp, paymasterServiceData) {
        var _a, _b;
        try {
          userOp = await this.prepareUserOperation(userOp);
        } catch (err) {
          common_1.Logger.log("Error in prepareUserOperation ", err);
          throw err;
        }
        if ((paymasterServiceData === null || paymasterServiceData === void 0 ? void 0 : paymasterServiceData.mode) === void 0) {
          throw new Error("mode is required in paymasterServiceData");
        }
        const mode = paymasterServiceData.mode;
        common_1.Logger.log("requested mode is ", mode);
        const calculateGasLimits = (paymasterServiceData === null || paymasterServiceData === void 0 ? void 0 : paymasterServiceData.calculateGasLimits) ? paymasterServiceData.calculateGasLimits : false;
        common_1.Logger.log("calculateGasLimits is ", calculateGasLimits);
        let tokenInfo = null;
        let smartAccountInfo = {
          name: "BICONOMY",
          version: "1.0.0"
        };
        let webhookData = null;
        if (mode === Types_1.PaymasterMode.ERC20) {
          if (!(paymasterServiceData === null || paymasterServiceData === void 0 ? void 0 : paymasterServiceData.feeTokenAddress) && (paymasterServiceData === null || paymasterServiceData === void 0 ? void 0 : paymasterServiceData.feeTokenAddress) === ethers_1.ethers.constants.AddressZero) {
            throw new Error("feeTokenAddress is required and should be non-zero");
          }
          tokenInfo = {
            feeTokenAddress: paymasterServiceData.feeTokenAddress
          };
        }
        webhookData = (_a = paymasterServiceData === null || paymasterServiceData === void 0 ? void 0 : paymasterServiceData.webhookData) !== null && _a !== void 0 ? _a : webhookData;
        smartAccountInfo = (_b = paymasterServiceData === null || paymasterServiceData === void 0 ? void 0 : paymasterServiceData.smartAccountInfo) !== null && _b !== void 0 ? _b : smartAccountInfo;
        try {
          const response = await (0, common_1.sendRequest)({
            url: `${this.paymasterConfig.paymasterUrl}`,
            method: common_1.HttpMethod.Post,
            body: {
              method: "pm_sponsorUserOperation",
              params: [
                userOp,
                {
                  mode,
                  calculateGasLimits,
                  ...tokenInfo !== null && { tokenInfo },
                  sponsorshipInfo: {
                    ...webhookData !== null && { webhookData },
                    smartAccountInfo
                  }
                }
              ],
              id: (0, common_1.getTimestampInSeconds)(),
              jsonrpc: "2.0"
            }
          });
          common_1.Logger.log("verifying and signing service response", response);
          if (response && response.result) {
            const paymasterAndData = response.result.paymasterAndData;
            const preVerificationGas = response.result.preVerificationGas;
            const verificationGasLimit = response.result.verificationGasLimit;
            const callGasLimit = response.result.callGasLimit;
            return {
              paymasterAndData,
              preVerificationGas,
              verificationGasLimit,
              callGasLimit
            };
          }
        } catch (error) {
          common_1.Logger.log(error.message);
          common_1.Logger.error("Error in generating paymasterAndData - reason: ", JSON.stringify(error));
          if (!this.paymasterConfig.strictMode && ((error === null || error === void 0 ? void 0 : error.message.includes("Smart contract data not found")) || (error === null || error === void 0 ? void 0 : error.message.includes("No policies were set")))) {
            common_1.Logger.log(`Strict mode is ${this.paymasterConfig.strictMode}. sending paymasterAndData 0x`);
            return {
              paymasterAndData: "0x",
              // send below values same as userOp gasLimits
              preVerificationGas: userOp.preVerificationGas,
              verificationGasLimit: userOp.verificationGasLimit,
              callGasLimit: userOp.callGasLimit
            };
          }
          throw error;
        }
        throw new Error("Error in generating paymasterAndData");
      }
      /**
       *
       * @param userOp user operation
       * @param paymasterServiceData optional extra information to be passed to paymaster service
       * @returns paymasterAndData with valid length but mock signature
       */
      async getDummyPaymasterAndData(userOp, paymasterServiceData) {
        common_1.Logger.log("userOp is ", userOp);
        common_1.Logger.log("paymasterServiceData is ", paymasterServiceData);
        return "0x";
      }
    };
    exports.BiconomyPaymaster = BiconomyPaymaster;
  }
});

// node_modules/@biconomy/paymaster/dist/src/index.js
var require_src2 = __commonJS({
  "node_modules/@biconomy/paymaster/dist/src/index.js"(exports) {
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_IPaymaster(), exports);
    __exportStar(require_IHybridPaymaster(), exports);
    __exportStar(require_Types(), exports);
    __exportStar(require_BiconomyPaymaster(), exports);
  }
});

export {
  require_src2 as require_src
};
//# sourceMappingURL=chunk-IUPMYWVU.js.map
