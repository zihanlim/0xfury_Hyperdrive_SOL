"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BiconomySmartAccountV2 = void 0;
const providers_1 = require("@ethersproject/providers");
const ethers_1 = require("ethers");
const BaseSmartAccount_1 = require("./BaseSmartAccount");
const utils_1 = require("ethers/lib/utils");
const common_1 = require("@biconomy/common");
const modules_1 = require("@biconomy/modules");
const node_client_1 = __importDefault(require("@biconomy/node-client"));
const paymaster_1 = require("@biconomy/paymaster");
const Constants_1 = require("./utils/Constants");
class BiconomySmartAccountV2 extends BaseSmartAccount_1.BaseSmartAccount {
    constructor(biconomySmartAccountConfig) {
        super(biconomySmartAccountConfig);
        this.biconomySmartAccountConfig = biconomySmartAccountConfig;
        this.SENTINEL_MODULE = "0x0000000000000000000000000000000000000001";
    }
    static async create(biconomySmartAccountConfig) {
        var _a, _b, _c;
        const instance = new BiconomySmartAccountV2(biconomySmartAccountConfig);
        await instance.init();
        instance.factoryAddress = (_a = biconomySmartAccountConfig.factoryAddress) !== null && _a !== void 0 ? _a : Constants_1.DEFAULT_BICONOMY_FACTORY_ADDRESS; // This would be fetched from V2
        const defaultFallbackHandlerAddress = instance.factoryAddress === Constants_1.DEFAULT_BICONOMY_FACTORY_ADDRESS
            ? Constants_1.DEFAULT_FALLBACK_HANDLER_ADDRESS
            : biconomySmartAccountConfig.defaultFallbackHandler;
        if (!defaultFallbackHandlerAddress) {
            throw new Error("Default Fallback Handler address is not provided");
        }
        instance.defaultFallbackHandlerAddress = defaultFallbackHandlerAddress;
        instance.implementationAddress = (_b = biconomySmartAccountConfig.implementationAddress) !== null && _b !== void 0 ? _b : Constants_1.BICONOMY_IMPLEMENTATION_ADDRESSES_BY_VERSION.V2_0_0;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        instance.defaultValidationModule = biconomySmartAccountConfig.defaultValidationModule;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        instance.activeValidationModule = (_c = biconomySmartAccountConfig.activeValidationModule) !== null && _c !== void 0 ? _c : instance.defaultValidationModule;
        const { rpcUrl, nodeClientUrl } = biconomySmartAccountConfig;
        if (rpcUrl) {
            instance.provider = new providers_1.JsonRpcProvider(rpcUrl);
        }
        instance.nodeClient = new node_client_1.default({ txServiceUrl: nodeClientUrl !== null && nodeClientUrl !== void 0 ? nodeClientUrl : common_1.NODE_CLIENT_URL });
        return instance;
    }
    async _getAccountContract() {
        if (this.accountContract == null) {
            this.accountContract = common_1.SmartAccount_v200__factory.connect(await this.getAccountAddress(), this.provider);
        }
        return this.accountContract;
    }
    isActiveValidationModuleDefined() {
        if (!this.activeValidationModule)
            throw new Error("Must provide an instance of active validation module.");
        return true;
    }
    isDefaultValidationModuleDefined() {
        if (!this.defaultValidationModule)
            throw new Error("Must provide an instance of default validation module.");
        return true;
    }
    setActiveValidationModule(validationModule) {
        if (validationModule instanceof modules_1.BaseValidationModule) {
            this.activeValidationModule = validationModule;
        }
        return this;
    }
    setDefaultValidationModule(validationModule) {
        if (validationModule instanceof modules_1.BaseValidationModule) {
            this.defaultValidationModule = validationModule;
            this.accountAddress = undefined;
        }
        return this;
    }
    // Could call it nonce space
    async getNonce(nonceKey) {
        const nonceSpace = nonceKey !== null && nonceKey !== void 0 ? nonceKey : 0;
        if (await this.isAccountDeployed(await this.getAccountAddress())) {
            const accountContract = await this._getAccountContract();
            return accountContract.nonce(nonceSpace);
        }
        return ethers_1.BigNumber.from(0);
    }
    /**
     * return the account's address.
     * this value is valid even before deploying the contract.
     */
    async getAccountAddress(params) {
        if (this.accountAddress == null) {
            // means it needs deployment
            this.accountAddress = await this.getCounterFactualAddress(params);
        }
        return this.accountAddress;
    }
    /**
     * calculate the account address even before it is deployed
     */
    async getCounterFactualAddress(params) {
        var _a, _b;
        if (this.factory == null) {
            if (this.factoryAddress != null && this.factoryAddress !== "") {
                this.factory = common_1.SmartAccountFactory_v200__factory.connect(this.factoryAddress, this.provider);
            }
            else {
                throw new Error("no factory to get initCode");
            }
        }
        const validationModule = (_a = params === null || params === void 0 ? void 0 : params.validationModule) !== null && _a !== void 0 ? _a : this.defaultValidationModule;
        const index = (_b = params === null || params === void 0 ? void 0 : params.index) !== null && _b !== void 0 ? _b : this.index;
        try {
            const initCalldata = common_1.SmartAccount_v200__factory.createInterface().encodeFunctionData("init", [
                this.defaultFallbackHandlerAddress,
                validationModule.getAddress(),
                await validationModule.getInitData(),
            ]);
            const proxyCreationCodeHash = (0, utils_1.solidityKeccak256)(["bytes", "uint256"], [Constants_1.PROXY_CREATION_CODE, this.implementationAddress]);
            const salt = (0, utils_1.solidityKeccak256)(["bytes32", "uint256"], [(0, utils_1.keccak256)(initCalldata), index]);
            const counterFactualAddress = (0, utils_1.getCreate2Address)(this.factory.address, salt, proxyCreationCodeHash);
            return counterFactualAddress;
        }
        catch (e) {
            throw new Error(`Failed to get counterfactual address, ${e}`);
        }
    }
    /**
     * return the value to put into the "initCode" field, if the account is not yet deployed.
     * this value holds the "factory" address, followed by this account's information
     */
    async getAccountInitCode() {
        if (this.factory == null) {
            if (this.factoryAddress != null && this.factoryAddress !== "") {
                this.factory = common_1.SmartAccountFactory_v200__factory.connect(this.factoryAddress, this.provider);
            }
            else {
                throw new Error("no factory to get initCode");
            }
        }
        this.isDefaultValidationModuleDefined();
        return (0, utils_1.hexConcat)([
            this.factory.address,
            this.factory.interface.encodeFunctionData("deployCounterFactualAccount", [
                this.defaultValidationModule.getAddress(),
                await this.defaultValidationModule.getInitData(),
                this.index,
            ]),
        ]);
    }
    /**
     *
     * @param to { target } address of transaction
     * @param value  represents amount of native tokens
     * @param data represent data associated with transaction
     * @returns
     */
    async encodeExecute(to, value, data) {
        const accountContract = await this._getAccountContract();
        return accountContract.interface.encodeFunctionData("execute_ncC", [to, value, data]);
    }
    /**
     *
     * @param to { target } array of addresses in transaction
     * @param value  represents array of amount of native tokens associated with each transaction
     * @param data represent array of data associated with each transaction
     * @returns
     */
    async encodeExecuteBatch(to, value, data) {
        const accountContract = await this._getAccountContract();
        return accountContract.interface.encodeFunctionData("executeBatch_y6U", [to, value, data]);
    }
    // dummy signature depends on the validation module supplied.
    async getDummySignature(params) {
        this.isActiveValidationModuleDefined();
        return this.activeValidationModule.getDummySignature(params);
    }
    // Might use provided paymaster instance to get dummy data (from pm service)
    getDummyPaymasterData() {
        return "0x";
    }
    async signUserOp(userOp, params) {
        this.isActiveValidationModuleDefined();
        const requiredFields = [
            "sender",
            "nonce",
            "initCode",
            "callData",
            "callGasLimit",
            "verificationGasLimit",
            "preVerificationGas",
            "maxFeePerGas",
            "maxPriorityFeePerGas",
            "paymasterAndData",
        ];
        super.validateUserOp(userOp, requiredFields);
        const userOpHash = await this.getUserOpHash(userOp);
        const moduleSig = await this.activeValidationModule.signUserOpHash(userOpHash, params);
        // Note: If the account is undeployed, use ERC-6492
        // Review: Should only be needed for signMessage
        /*if (!(await this.isAccountDeployed(await this.getAccountAddress()))) {
          const coder = new ethers.utils.AbiCoder();
          const populatedTransaction = await this.factory?.populateTransaction.deployCounterFactualAccount(
            await this.defaultValidationModule.getAddress(),
            await this.defaultValidationModule.getInitData(),
            this.index,
          );
          moduleSig =
            coder.encode(["address", "bytes", "bytes"], [this.factoryAddress, populatedTransaction?.data, moduleSig]) +
            "6492649264926492649264926492649264926492649264926492649264926492"; // magic suffix
          userOp.signature = moduleSig;
          return userOp as UserOperation;
        }*/
        const signatureWithModuleAddress = ethers_1.ethers.utils.defaultAbiCoder.encode(["bytes", "address"], [moduleSig, this.activeValidationModule.getAddress()]);
        userOp.signature = signatureWithModuleAddress;
        return userOp;
    }
    getSignatureWithModuleAddress(moduleSignature, moduleAddress) {
        const moduleAddressToUse = moduleAddress !== null && moduleAddress !== void 0 ? moduleAddress : this.activeValidationModule.getAddress();
        return ethers_1.ethers.utils.defaultAbiCoder.encode(["bytes", "address"], [moduleSignature, moduleAddressToUse]);
    }
    /**
     *
     * @param userOp
     * @param params
     * @description This function call will take 'unsignedUserOp' as an input, sign it with the owner key, and send it to the bundler.
     * @returns Promise<UserOpResponse>
     */
    async sendUserOp(userOp, params) {
        common_1.Logger.log("userOp received in base account ", userOp);
        delete userOp.signature;
        const userOperation = await this.signUserOp(userOp, params);
        const bundlerResponse = await this.sendSignedUserOp(userOperation);
        return bundlerResponse;
    }
    async buildUserOp(transactions, buildUseropDto) {
        var _a, _b;
        const to = transactions.map((element) => element.to);
        const data = transactions.map((element) => { var _a; return (_a = element.data) !== null && _a !== void 0 ? _a : "0x"; });
        const value = transactions.map((element) => { var _a; return (_a = element.value) !== null && _a !== void 0 ? _a : ethers_1.BigNumber.from("0"); });
        // Queue promises to fetch independent data.
        const nonceFetchPromise = (async () => {
            var _a, _b;
            const _nonceSpace = (_b = (_a = buildUseropDto === null || buildUseropDto === void 0 ? void 0 : buildUseropDto.nonceOptions) === null || _a === void 0 ? void 0 : _a.nonceKey) !== null && _b !== void 0 ? _b : 0;
            const nonce = await this.getNonce(_nonceSpace);
            return nonce;
        })();
        const initCodeFetchPromise = this.getInitCode();
        const dummySignatureFetchPromise = this.getDummySignature(buildUseropDto === null || buildUseropDto === void 0 ? void 0 : buildUseropDto.params);
        if (transactions.length === 0) {
            throw new Error("Transactions array cannot be empty");
        }
        let callData = "";
        if (transactions.length > 1 || (buildUseropDto === null || buildUseropDto === void 0 ? void 0 : buildUseropDto.forceEncodeForBatch)) {
            callData = await this.encodeExecuteBatch(to, value, data);
        }
        else {
            // transactions.length must be 1
            callData = await this.encodeExecute(to[0], value[0], data[0]);
        }
        let nonce = ethers_1.BigNumber.from(0);
        try {
            if ((_a = buildUseropDto === null || buildUseropDto === void 0 ? void 0 : buildUseropDto.nonceOptions) === null || _a === void 0 ? void 0 : _a.nonceOverride) {
                nonce = ethers_1.BigNumber.from((_b = buildUseropDto === null || buildUseropDto === void 0 ? void 0 : buildUseropDto.nonceOptions) === null || _b === void 0 ? void 0 : _b.nonceOverride);
            }
            else {
                nonce = await nonceFetchPromise;
            }
        }
        catch (error) {
            // Not throwing this error as nonce would be 0 if this.getNonce() throw exception, which is expected flow for undeployed account
        }
        let userOp = {
            sender: await this.getAccountAddress(),
            nonce,
            initCode: await initCodeFetchPromise,
            callData: callData,
        };
        // for this Smart Account current validation module dummy signature will be used to estimate gas
        userOp.signature = await dummySignatureFetchPromise;
        // Note: Can change the default behaviour of calling estimations using bundler/local
        userOp = await this.estimateUserOpGas(userOp, buildUseropDto === null || buildUseropDto === void 0 ? void 0 : buildUseropDto.overrides, buildUseropDto === null || buildUseropDto === void 0 ? void 0 : buildUseropDto.skipBundlerGasEstimation);
        common_1.Logger.log("UserOp after estimation ", userOp);
        // Do not populate paymasterAndData as part of buildUserOp as it may not have all necessary details
        userOp.paymasterAndData = "0x"; // await this.getPaymasterAndData(userOp)
        return userOp;
    }
    validateUserOpAndPaymasterRequest(userOp, tokenPaymasterRequest) {
        var _a;
        if (!userOp.callData) {
            throw new Error("UserOp callData cannot be undefined");
        }
        const feeTokenAddress = (_a = tokenPaymasterRequest === null || tokenPaymasterRequest === void 0 ? void 0 : tokenPaymasterRequest.feeQuote) === null || _a === void 0 ? void 0 : _a.tokenAddress;
        common_1.Logger.log("Requested fee token is ", feeTokenAddress);
        if (!feeTokenAddress || feeTokenAddress == ethers_1.ethers.constants.AddressZero) {
            throw new Error("Invalid or missing token address. Token address must be part of the feeQuote in tokenPaymasterRequest");
        }
        const spender = tokenPaymasterRequest === null || tokenPaymasterRequest === void 0 ? void 0 : tokenPaymasterRequest.spender;
        common_1.Logger.log("Spender address is ", spender);
        if (!spender || spender == ethers_1.ethers.constants.AddressZero) {
            throw new Error("Invalid or missing spender address. Sepnder address must be part of tokenPaymasterRequest");
        }
    }
    /**
     *
     * @param userOp partial user operation without signature and paymasterAndData
     * @param tokenPaymasterRequest This dto provides information about fee quote. Fee quote is received from earlier request getFeeQuotesOrData() to the Biconomy paymaster.
     *  maxFee and token decimals from the quote, along with the spender is required to append approval transaction.
     * @notice This method should be called when gas is paid in ERC20 token using TokenPaymaster
     * @description Optional method to update the userOp.calldata with batched transaction which approves the paymaster spender with necessary amount(if required)
     * @returns updated userOp with new callData, callGasLimit
     */
    async buildTokenPaymasterUserOp(userOp, tokenPaymasterRequest) {
        this.validateUserOpAndPaymasterRequest(userOp, tokenPaymasterRequest);
        try {
            let batchTo = [];
            let batchValue = [];
            let batchData = [];
            let newCallData = userOp.callData;
            common_1.Logger.log("Received information about fee token address and quote ", tokenPaymasterRequest);
            if (this.paymaster && this.paymaster instanceof paymaster_1.BiconomyPaymaster) {
                // Make a call to paymaster.buildTokenApprovalTransaction() with necessary details
                // Review: might request this form of an array of Transaction
                const approvalRequest = await this.paymaster.buildTokenApprovalTransaction(tokenPaymasterRequest, this.provider);
                common_1.Logger.log("ApprovalRequest is for erc20 token ", approvalRequest.to);
                if (approvalRequest.data == "0x" || approvalRequest.to == ethers_1.ethers.constants.AddressZero) {
                    return userOp;
                }
                if (!userOp.callData) {
                    throw new Error("UserOp callData cannot be undefined");
                }
                const account = await this._getAccountContract();
                const decodedSmartAccountData = account.interface.parseTransaction({
                    data: userOp.callData.toString(),
                });
                if (!decodedSmartAccountData) {
                    throw new Error("Could not parse userOp call data for this smart account");
                }
                const smartAccountExecFunctionName = decodedSmartAccountData.name;
                common_1.Logger.log(`Originally an ${smartAccountExecFunctionName} method call for Biconomy Account V2`);
                if (smartAccountExecFunctionName === "execute" || smartAccountExecFunctionName === "execute_ncC") {
                    const methodArgsSmartWalletExecuteCall = decodedSmartAccountData.args;
                    const toOriginal = methodArgsSmartWalletExecuteCall[0];
                    const valueOriginal = methodArgsSmartWalletExecuteCall[1];
                    const dataOriginal = methodArgsSmartWalletExecuteCall[2];
                    batchTo.push(toOriginal);
                    batchValue.push(valueOriginal);
                    batchData.push(dataOriginal);
                }
                else if (smartAccountExecFunctionName === "executeBatch" || smartAccountExecFunctionName === "executeBatch_y6U") {
                    const methodArgsSmartWalletExecuteCall = decodedSmartAccountData.args;
                    batchTo = methodArgsSmartWalletExecuteCall[0];
                    batchValue = methodArgsSmartWalletExecuteCall[1];
                    batchData = methodArgsSmartWalletExecuteCall[2];
                }
                if (approvalRequest.to && approvalRequest.data && approvalRequest.value) {
                    batchTo = [approvalRequest.to, ...batchTo];
                    batchValue = [approvalRequest.value, ...batchValue];
                    batchData = [approvalRequest.data, ...batchData];
                    newCallData = await this.encodeExecuteBatch(batchTo, batchValue, batchData);
                }
                let finalUserOp = {
                    ...userOp,
                    callData: newCallData,
                };
                // Requesting to update gas limits again (especially callGasLimit needs to be re-calculated)
                try {
                    finalUserOp = await this.estimateUserOpGas(finalUserOp);
                    const callGasLimit = ethers_1.ethers.BigNumber.from(finalUserOp.callGasLimit);
                    if (finalUserOp.callGasLimit && callGasLimit.lt(ethers_1.ethers.BigNumber.from("21000"))) {
                        return {
                            ...userOp,
                            callData: newCallData,
                        };
                    }
                    common_1.Logger.log("UserOp after estimation ", finalUserOp);
                }
                catch (error) {
                    common_1.Logger.error("Failed to estimate gas for userOp with updated callData ", error);
                    common_1.Logger.log("Sending updated userOp. calculateGasLimit flag should be sent to the paymaster to be able to update callGasLimit");
                }
                return finalUserOp;
            }
        }
        catch (error) {
            common_1.Logger.log("Failed to update userOp. Sending back original op");
            common_1.Logger.error("Failed to update callData with error", error);
            return userOp;
        }
        return userOp;
    }
    async signUserOpHash(userOpHash, params) {
        this.isActiveValidationModuleDefined();
        const moduleSig = await this.activeValidationModule.signUserOpHash(userOpHash, params);
        const signatureWithModuleAddress = ethers_1.ethers.utils.defaultAbiCoder.encode(["bytes", "address"], [moduleSig, this.activeValidationModule.getAddress()]);
        return signatureWithModuleAddress;
    }
    async signMessage(message) {
        var _a;
        this.isActiveValidationModuleDefined();
        const dataHash = ethers_1.ethers.utils.arrayify(ethers_1.ethers.utils.hashMessage(message));
        let signature = await this.activeValidationModule.signMessage(dataHash);
        if (signature.slice(0, 2) !== "0x") {
            signature = "0x" + signature;
        }
        // If the account is undeployed, use ERC-6492
        if (!(await this.isAccountDeployed(await this.getAccountAddress()))) {
            const coder = new ethers_1.ethers.utils.AbiCoder();
            const populatedTransaction = await ((_a = this.factory) === null || _a === void 0 ? void 0 : _a.populateTransaction.deployCounterFactualAccount(await this.defaultValidationModule.getAddress(), await this.defaultValidationModule.getInitData(), this.index));
            signature =
                coder.encode(["address", "bytes", "bytes"], [this.factoryAddress, populatedTransaction === null || populatedTransaction === void 0 ? void 0 : populatedTransaction.data, signature]) +
                    "6492649264926492649264926492649264926492649264926492649264926492"; // magic suffix
        }
        return signature;
    }
    async getAllTokenBalances(balancesDto) {
        return this.nodeClient.getAllTokenBalances(balancesDto);
    }
    async getTotalBalanceInUsd(balancesDto) {
        return this.nodeClient.getTotalBalanceInUsd(balancesDto);
    }
    async getSmartAccountsByOwner(smartAccountByOwnerDto) {
        return this.nodeClient.getSmartAccountsByOwner(smartAccountByOwnerDto);
    }
    async getTransactionsByAddress(chainId, address) {
        return this.nodeClient.getTransactionByAddress(chainId, address);
    }
    async getTransactionByHash(txHash) {
        return this.nodeClient.getTransactionByHash(txHash);
    }
    async getAllSupportedChains() {
        return this.nodeClient.getAllSupportedChains();
    }
    getImplementationAddress() {
        return this.implementationAddress;
    }
    async enableModule(moduleAddress) {
        const tx = await this.getEnableModuleData(moduleAddress);
        const partialUserOp = await this.buildUserOp([tx]);
        return this.sendUserOp(partialUserOp);
    }
    async getEnableModuleData(moduleAddress) {
        const accountContract = await this._getAccountContract();
        const data = accountContract.interface.encodeFunctionData("enableModule", [moduleAddress]);
        const tx = {
            to: await this.getAccountAddress(),
            value: "0",
            data: data,
        };
        return tx;
    }
    async getSetupAndEnableModuleData(moduleAddress, moduleSetupData) {
        const accountContract = await this._getAccountContract();
        const data = accountContract.interface.encodeFunctionData("setupAndEnableModule", [moduleAddress, moduleSetupData]);
        const tx = {
            to: await this.getAccountAddress(),
            value: "0",
            data: data,
        };
        return tx;
    }
    async disableModule(prevModule, moduleAddress) {
        const tx = await this.getDisableModuleData(prevModule, moduleAddress);
        const partialUserOp = await this.buildUserOp([tx]);
        return this.sendUserOp(partialUserOp);
    }
    async getDisableModuleData(prevModule, moduleAddress) {
        const accountContract = await this._getAccountContract();
        const data = accountContract.interface.encodeFunctionData("disableModule", [prevModule, moduleAddress]);
        const tx = {
            to: await this.getAccountAddress(),
            value: "0",
            data: data,
        };
        return tx;
    }
    async isModuleEnabled(moduleName) {
        const accountContract = await this._getAccountContract();
        return accountContract.isModuleEnabled(moduleName);
    }
    async getAllModules(pageSize) {
        pageSize = pageSize !== null && pageSize !== void 0 ? pageSize : 100;
        const accountContract = await this._getAccountContract();
        // Note: If page size is lower then on the next page start module would be module at the end of first page and not SENTINEL_MODULE
        const result = await accountContract.getModulesPaginated(this.SENTINEL_MODULE, pageSize);
        const modules = result[0];
        return modules;
    }
}
exports.BiconomySmartAccountV2 = BiconomySmartAccountV2;
//# sourceMappingURL=BiconomySmartAccountV2.js.map