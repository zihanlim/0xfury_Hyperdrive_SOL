"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BiconomySmartAccount = void 0;
const providers_1 = require("@ethersproject/providers");
const ethers_1 = require("ethers");
const SmartAccount_1 = require("./SmartAccount");
const common_1 = require("@biconomy/common");
const core_types_1 = require("@biconomy/core-types");
const node_client_1 = __importDefault(require("@biconomy/node-client"));
const paymaster_1 = require("@biconomy/paymaster");
const Constants_1 = require("./utils/Constants");
class BiconomySmartAccount extends SmartAccount_1.SmartAccount {
    constructor(biconomySmartAccountConfig) {
        const { signer, rpcUrl, entryPointAddress, bundler, paymaster, chainId, nodeClientUrl } = biconomySmartAccountConfig;
        const _entryPointAddress = entryPointAddress !== null && entryPointAddress !== void 0 ? entryPointAddress : Constants_1.DEFAULT_ENTRYPOINT_ADDRESS;
        super({
            bundler,
            entryPointAddress: _entryPointAddress,
        });
        this.biconomySmartAccountConfig = biconomySmartAccountConfig;
        const _rpcUrl = rpcUrl !== null && rpcUrl !== void 0 ? rpcUrl : common_1.RPC_PROVIDER_URLS[chainId];
        if (!_rpcUrl) {
            throw new Error(`Chain Id ${chainId} is not supported. Please refer to the following link for supported chains list https://docs.biconomy.io/build-with-biconomy-sdk/gasless-transactions#supported-chains`);
        }
        this.provider = new providers_1.JsonRpcProvider(_rpcUrl);
        this.nodeClient = new node_client_1.default({ txServiceUrl: nodeClientUrl !== null && nodeClientUrl !== void 0 ? nodeClientUrl : common_1.NODE_CLIENT_URL });
        this.signer = signer;
        if (paymaster) {
            this.paymaster = paymaster;
        }
        if (bundler)
            this.bundler = bundler;
    }
    /**
     * @description This function will initialise BiconomyAccount class state
     * @returns Promise<BiconomyAccount>
     */
    async init(initilizationData) {
        try {
            let _accountIndex, signerAddress;
            if (initilizationData) {
                _accountIndex = initilizationData.accountIndex;
                signerAddress = initilizationData.signerAddress;
            }
            if (!_accountIndex)
                _accountIndex = 0;
            this.isProviderDefined();
            this.isSignerDefined();
            if (signerAddress) {
                this.owner = signerAddress;
            }
            else {
                this.owner = await this.signer.getAddress();
            }
            this.chainId = await this.provider.getNetwork().then((net) => net.chainId);
            await this.initializeAccountAtIndex(_accountIndex);
            this._isInitialised = true;
        }
        catch (error) {
            common_1.Logger.error(`Failed to call init: ${error}`);
            throw error;
        }
        return this;
    }
    async attachSigner(_signer) {
        try {
            this.signer = _signer;
            this.owner = await this.signer.getAddress();
        }
        catch (error) {
            throw new Error(`Failed to get signer address`);
        }
    }
    isInitialized() {
        if (!this._isInitialised)
            throw new Error("BiconomySmartAccount is not initialized. Please call init() on BiconomySmartAccount instance before interacting with any other function");
        return true;
    }
    setProxyContractState() {
        if (!Constants_1.BICONOMY_IMPLEMENTATION_ADDRESSES[this.smartAccountInfo.implementationAddress])
            throw new Error("Could not find attached implementation address against your smart account. Please raise an issue on https://github.com/bcnmy/biconomy-client-sdk for further investigation.");
        const proxyInstanceDto = {
            smartAccountType: core_types_1.SmartAccountType.BICONOMY,
            version: Constants_1.BICONOMY_IMPLEMENTATION_ADDRESSES[this.smartAccountInfo.implementationAddress],
            contractAddress: this.address,
            provider: this.provider,
        };
        this.proxy = (0, common_1.getSAProxyContract)(proxyInstanceDto);
    }
    setEntryPointContractState() {
        const _entryPointAddress = this.smartAccountInfo.entryPointAddress;
        this.setEntryPointAddress(_entryPointAddress);
        if (!Constants_1.ENTRYPOINT_ADDRESSES[_entryPointAddress])
            throw new Error("Could not find attached entrypoint address against your smart account. Please raise an issue on https://github.com/bcnmy/biconomy-client-sdk for further investigation.");
        const entryPointInstanceDto = {
            smartAccountType: core_types_1.SmartAccountType.BICONOMY,
            version: Constants_1.ENTRYPOINT_ADDRESSES[_entryPointAddress],
            contractAddress: _entryPointAddress,
            provider: this.provider,
        };
        this.entryPoint = (0, common_1.getEntryPointContract)(entryPointInstanceDto);
    }
    setFactoryContractState() {
        const _factoryAddress = this.smartAccountInfo.factoryAddress;
        if (!Constants_1.BICONOMY_FACTORY_ADDRESSES[_factoryAddress])
            throw new Error("Could not find attached factory address against your smart account. Please raise an issue on https://github.com/bcnmy/biconomy-client-sdk for further investigation.");
        const factoryInstanceDto = {
            smartAccountType: core_types_1.SmartAccountType.BICONOMY,
            version: Constants_1.BICONOMY_FACTORY_ADDRESSES[_factoryAddress],
            contractAddress: _factoryAddress,
            provider: this.provider,
        };
        this.factory = (0, common_1.getSAFactoryContract)(factoryInstanceDto);
    }
    async setContractsState() {
        this.setProxyContractState();
        this.setEntryPointContractState();
        this.setFactoryContractState();
    }
    async initializeAccountAtIndex(accountIndex) {
        this.accountIndex = accountIndex;
        this.address = await this.getSmartAccountAddress(accountIndex);
        await this.setContractsState();
        await this.setInitCode(this.accountIndex);
    }
    async getSmartAccountAddress(accountIndex = 0) {
        try {
            this.isSignerDefined();
            let smartAccountsList = (await this.getSmartAccountsByOwner({
                chainId: this.chainId,
                owner: this.owner,
                index: accountIndex,
            })).data;
            if (!smartAccountsList)
                throw new Error("Failed to get smart account address. Please raise an issue on https://github.com/bcnmy/biconomy-client-sdk for further investigation.");
            smartAccountsList = smartAccountsList.filter((smartAccount) => {
                return accountIndex === smartAccount.index;
            });
            if (smartAccountsList.length === 0)
                throw new Error("Failed to get smart account address. Please raise an issue on https://github.com/bcnmy/biconomy-client-sdk for further investigation.");
            this.smartAccountInfo = smartAccountsList[0];
            return this.smartAccountInfo.smartAccountAddress;
        }
        catch (error) {
            common_1.Logger.error(`Failed to get smart account address: ${error}`);
            throw error;
        }
    }
    async setInitCode(accountIndex = 0) {
        this.initCode = ethers_1.ethers.utils.hexConcat([
            this.factory.address,
            this.factory.interface.encodeFunctionData("deployCounterFactualAccount", [this.owner, ethers_1.ethers.BigNumber.from(accountIndex)]),
        ]);
        return this.initCode;
    }
    /**
     * @description an overrided function to showcase overriding example
     * @returns
     */
    nonce() {
        this.isProxyDefined();
        return this.proxy.nonce();
    }
    /**
     *
     * @param to { target } address of transaction
     * @param value  represents amount of native tokens
     * @param data represent data associated with transaction
     * @returns
     */
    getExecuteCallData(to, value, data) {
        this.isInitialized();
        this.isProxyDefined();
        const executeCallData = this.proxy.interface.encodeFunctionData("executeCall", [to, value, data]);
        return executeCallData;
    }
    /**
     *
     * @param to { target } array of addresses in transaction
     * @param value  represents array of amount of native tokens associated with each transaction
     * @param data represent array of data associated with each transaction
     * @returns
     */
    getExecuteBatchCallData(to, value, data) {
        this.isInitialized();
        this.isProxyDefined();
        const executeBatchCallData = this.proxy.interface.encodeFunctionData("executeBatchCall", [to, value, data]);
        return executeBatchCallData;
    }
    getDummySignature() {
        return "0x73c3ac716c487ca34bb858247b5ccf1dc354fbaabdd089af3b2ac8e78ba85a4959a2d76250325bd67c11771c31fccda87c33ceec17cc0de912690521bb95ffcb1b";
    }
    getDummyPaymasterData() {
        return "0x";
    }
    async buildUserOp(transactions, overrides, skipBundlerGasEstimation) {
        this.isInitialized();
        const to = transactions.map((element) => element.to);
        const data = transactions.map((element) => { var _a; return (_a = element.data) !== null && _a !== void 0 ? _a : "0x"; });
        const value = transactions.map((element) => { var _a; return (_a = element.value) !== null && _a !== void 0 ? _a : ethers_1.BigNumber.from("0"); });
        this.isProxyDefined();
        let callData = "";
        if (transactions.length === 1) {
            callData = this.getExecuteCallData(to[0], value[0], data[0]);
        }
        else {
            callData = this.getExecuteBatchCallData(to, value, data);
        }
        let nonce = ethers_1.BigNumber.from(0);
        try {
            nonce = await this.nonce();
        }
        catch (error) {
            // Not throwing this error as nonce would be 0 if this.nonce() throw exception, which is expected flow for undeployed account
        }
        let isDeployed = true;
        if (nonce.eq(0)) {
            isDeployed = await this.isAccountDeployed(this.address);
        }
        let userOp = {
            sender: this.address,
            nonce,
            initCode: !isDeployed ? this.initCode : "0x",
            callData: callData,
        };
        // for this Smart Account dummy ECDSA signature will be used to estimate gas
        userOp.signature = this.getDummySignature();
        userOp = await this.estimateUserOpGas(userOp, overrides, skipBundlerGasEstimation);
        common_1.Logger.log("userOp after estimation ", userOp);
        // Do not populate paymasterAndData as part of buildUserOp as it may not have all necessary details
        userOp.paymasterAndData = "0x"; // await this.getPaymasterAndData(userOp)
        return userOp;
    }
    validateUserOpAndRequest(userOp, tokenPaymasterRequest) {
        var _a;
        if (!userOp.callData) {
            throw new Error("Userop callData cannot be undefined");
        }
        const feeTokenAddress = (_a = tokenPaymasterRequest === null || tokenPaymasterRequest === void 0 ? void 0 : tokenPaymasterRequest.feeQuote) === null || _a === void 0 ? void 0 : _a.tokenAddress;
        common_1.Logger.log("requested fee token is ", feeTokenAddress);
        if (!feeTokenAddress || feeTokenAddress == ethers_1.ethers.constants.AddressZero) {
            throw new Error("Invalid or missing token address. Token address must be part of the feeQuote in tokenPaymasterRequest");
        }
        const spender = tokenPaymasterRequest === null || tokenPaymasterRequest === void 0 ? void 0 : tokenPaymasterRequest.spender;
        common_1.Logger.log("fee token approval to be checked and added for spender: ", spender);
        if (!spender || spender == ethers_1.ethers.constants.AddressZero) {
            throw new Error("Invalid or missing spender address. Sepnder address must be part of tokenPaymasterRequest");
        }
    }
    /**
     *
     * @param userOp partial user operation without signature and paymasterAndData
     * @param tokenPaymasterRequest This dto provides information about fee quote. Fee quote is received from earlier request getFeeQuotesOrData() to the Biconomy paymaster.
     *  maxFee and token decimals from the quote, along with the spender is required to append approval transaction.
     * @notice This method should be called when gas is paid in ERC20 token using TokenPaymaster
     * @description Optional method to update the userOp.calldata with batched transaction which approves the paymaster spender with necessary amount(if required)
     * @returns updated userOp with new callData, callGasLimit
     */
    async buildTokenPaymasterUserOp(userOp, tokenPaymasterRequest) {
        this.validateUserOpAndRequest(userOp, tokenPaymasterRequest);
        try {
            let batchTo = [];
            let batchValue = [];
            let batchData = [];
            let newCallData = userOp.callData;
            common_1.Logger.log("received information about fee token address and quote ", tokenPaymasterRequest);
            if (this.paymaster && this.paymaster instanceof paymaster_1.BiconomyPaymaster) {
                // Make a call to paymaster.buildTokenApprovalTransaction() with necessary details
                // Review: might request this form of an array of Transaction
                const approvalRequest = await this.paymaster.buildTokenApprovalTransaction(tokenPaymasterRequest, this.provider);
                common_1.Logger.log("approvalRequest is for erc20 token ", approvalRequest.to);
                if (approvalRequest.data == "0x" || approvalRequest.to == ethers_1.ethers.constants.AddressZero) {
                    return userOp;
                }
                if (!userOp.callData) {
                    throw new Error("Userop callData cannot be undefined");
                }
                const decodedDataSmartWallet = this.proxy.interface.parseTransaction({
                    data: userOp.callData.toString(),
                });
                if (!decodedDataSmartWallet) {
                    throw new Error("Could not parse call data of smart wallet for userOp");
                }
                const smartWalletExecFunctionName = decodedDataSmartWallet.name;
                if (smartWalletExecFunctionName === "executeCall") {
                    common_1.Logger.log("originally an executeCall for Biconomy Account");
                    const methodArgsSmartWalletExecuteCall = decodedDataSmartWallet.args;
                    const toOriginal = methodArgsSmartWalletExecuteCall[0];
                    const valueOriginal = methodArgsSmartWalletExecuteCall[1];
                    const dataOriginal = methodArgsSmartWalletExecuteCall[2];
                    batchTo.push(toOriginal);
                    batchValue.push(valueOriginal);
                    batchData.push(dataOriginal);
                }
                else if (smartWalletExecFunctionName === "executeBatchCall") {
                    common_1.Logger.log("originally an executeBatchCall for Biconomy Account");
                    const methodArgsSmartWalletExecuteCall = decodedDataSmartWallet.args;
                    batchTo = methodArgsSmartWalletExecuteCall[0];
                    batchValue = methodArgsSmartWalletExecuteCall[1];
                    batchData = methodArgsSmartWalletExecuteCall[2];
                }
                if (approvalRequest.to && approvalRequest.data && approvalRequest.value) {
                    batchTo = [approvalRequest.to, ...batchTo];
                    batchValue = [approvalRequest.value, ...batchValue];
                    batchData = [approvalRequest.data, ...batchData];
                    newCallData = this.getExecuteBatchCallData(batchTo, batchValue, batchData);
                }
                let finalUserOp = {
                    ...userOp,
                    callData: newCallData,
                };
                // Requesting to update gas limits again (especially callGasLimit needs to be re-calculated)
                try {
                    delete finalUserOp.callGasLimit;
                    delete finalUserOp.verificationGasLimit;
                    delete finalUserOp.preVerificationGas;
                    // Maybe send paymasterAndData since we know it's for Token paymaster
                    /*finalUserOp.paymasterAndData =
                      '0x00000f7365ca6c59a2c93719ad53d567ed49c14c000000000000000000000000000000000000000000000000000000000064e3d3890000000000000000000000000000000000000000000000000000000064e3cc81000000000000000000000000af88d065e77c8cc2239327c5edb3a432268e583100000000000000000000000000000f7748595e46527413574a9327942e744e910000000000000000000000000000000000000000000000000000000063ac7f6c000000000000000000000000000000000000000000000000000000000010c8e07bf61410b71700f943499adfd23e50fb16040d587acb0a5e60ac8576cdbb4c8044f00579a1fc3f294e7dc4a5eb557a7193008343aa36225bddcfbd4fd15646031c'*/
                    // Review: and handle the case when mock pnd fails with AA31 during simulation.
                    finalUserOp = await this.estimateUserOpGas(finalUserOp);
                    const cgl = ethers_1.ethers.BigNumber.from(finalUserOp.callGasLimit);
                    if (finalUserOp.callGasLimit && cgl.lt(ethers_1.ethers.BigNumber.from("21000"))) {
                        return {
                            ...userOp,
                            callData: newCallData,
                        };
                    }
                    common_1.Logger.log("userOp after estimation ", finalUserOp);
                }
                catch (error) {
                    common_1.Logger.error("Failed to estimate gas for userOp with updated callData ", error);
                    common_1.Logger.log("sending updated userOp. calculateGasLimit flag should be sent to the paymaster to be able to update callGasLimit");
                }
                return finalUserOp;
            }
        }
        catch (error) {
            common_1.Logger.log("Failed to update userOp. sending back original op");
            common_1.Logger.error("Failed to update callData with error", error);
            return userOp;
        }
        return userOp;
    }
    async getAllTokenBalances(balancesDto) {
        return this.nodeClient.getAllTokenBalances(balancesDto);
    }
    async getTotalBalanceInUsd(balancesDto) {
        return this.nodeClient.getTotalBalanceInUsd(balancesDto);
    }
    async getSmartAccountsByOwner(smartAccountByOwnerDto) {
        return this.nodeClient.getSmartAccountsByOwner(smartAccountByOwnerDto);
    }
    async getTransactionsByAddress(chainId, address) {
        return this.nodeClient.getTransactionByAddress(chainId, address);
    }
    async getTransactionByHash(txHash) {
        return this.nodeClient.getTransactionByHash(txHash);
    }
    async getAllSupportedChains() {
        return this.nodeClient.getAllSupportedChains();
    }
}
exports.BiconomySmartAccount = BiconomySmartAccount;
//# sourceMappingURL=BiconomySmartAccount.js.map