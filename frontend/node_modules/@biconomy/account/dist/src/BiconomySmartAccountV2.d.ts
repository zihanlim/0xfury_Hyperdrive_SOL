import { BigNumberish, BytesLike, BigNumber } from "ethers";
import { BaseSmartAccount } from "./BaseSmartAccount";
import { Bytes } from "ethers/lib/utils";
import { SmartAccount_v200, SmartAccountFactory_v200 } from "@biconomy/common";
import { BiconomyTokenPaymasterRequest, BiconomySmartAccountV2Config, CounterFactualAddressParam, BuildUserOpOptions } from "./utils/Types";
import { BaseValidationModule, ModuleInfo } from "@biconomy/modules";
import { UserOperation, Transaction } from "@biconomy/core-types";
import { SupportedChainsResponse, BalancesResponse, BalancesDto, UsdBalanceResponse, SmartAccountByOwnerDto, SmartAccountsResponse, SCWTransactionResponse } from "@biconomy/node-client";
import { UserOpResponse } from "@biconomy/bundler";
export declare class BiconomySmartAccountV2 extends BaseSmartAccount {
    readonly biconomySmartAccountConfig: BiconomySmartAccountV2Config;
    private nodeClient;
    private SENTINEL_MODULE;
    factoryAddress?: string;
    /**
     * our account contract.
     * should support the "execFromEntryPoint" and "nonce" methods
     */
    accountContract?: SmartAccount_v200;
    factory?: SmartAccountFactory_v200;
    private defaultFallbackHandlerAddress;
    private implementationAddress;
    defaultValidationModule: BaseValidationModule;
    activeValidationModule: BaseValidationModule;
    private constructor();
    static create(biconomySmartAccountConfig: BiconomySmartAccountV2Config): Promise<BiconomySmartAccountV2>;
    _getAccountContract(): Promise<SmartAccount_v200>;
    isActiveValidationModuleDefined(): boolean;
    isDefaultValidationModuleDefined(): boolean;
    setActiveValidationModule(validationModule: BaseValidationModule): BiconomySmartAccountV2;
    setDefaultValidationModule(validationModule: BaseValidationModule): BiconomySmartAccountV2;
    getNonce(nonceKey?: number): Promise<BigNumber>;
    /**
     * return the account's address.
     * this value is valid even before deploying the contract.
     */
    getAccountAddress(params?: CounterFactualAddressParam): Promise<string>;
    /**
     * calculate the account address even before it is deployed
     */
    getCounterFactualAddress(params?: CounterFactualAddressParam): Promise<string>;
    /**
     * return the value to put into the "initCode" field, if the account is not yet deployed.
     * this value holds the "factory" address, followed by this account's information
     */
    getAccountInitCode(): Promise<string>;
    /**
     *
     * @param to { target } address of transaction
     * @param value  represents amount of native tokens
     * @param data represent data associated with transaction
     * @returns
     */
    encodeExecute(to: string, value: BigNumberish, data: BytesLike): Promise<string>;
    /**
     *
     * @param to { target } array of addresses in transaction
     * @param value  represents array of amount of native tokens associated with each transaction
     * @param data represent array of data associated with each transaction
     * @returns
     */
    encodeExecuteBatch(to: Array<string>, value: Array<BigNumberish>, data: Array<BytesLike>): Promise<string>;
    getDummySignature(params?: ModuleInfo): Promise<string>;
    getDummyPaymasterData(): string;
    signUserOp(userOp: Partial<UserOperation>, params?: ModuleInfo): Promise<UserOperation>;
    getSignatureWithModuleAddress(moduleSignature: string, moduleAddress?: string): string;
    /**
     *
     * @param userOp
     * @param params
     * @description This function call will take 'unsignedUserOp' as an input, sign it with the owner key, and send it to the bundler.
     * @returns Promise<UserOpResponse>
     */
    sendUserOp(userOp: Partial<UserOperation>, params?: ModuleInfo): Promise<UserOpResponse>;
    buildUserOp(transactions: Transaction[], buildUseropDto?: BuildUserOpOptions): Promise<Partial<UserOperation>>;
    private validateUserOpAndPaymasterRequest;
    /**
     *
     * @param userOp partial user operation without signature and paymasterAndData
     * @param tokenPaymasterRequest This dto provides information about fee quote. Fee quote is received from earlier request getFeeQuotesOrData() to the Biconomy paymaster.
     *  maxFee and token decimals from the quote, along with the spender is required to append approval transaction.
     * @notice This method should be called when gas is paid in ERC20 token using TokenPaymaster
     * @description Optional method to update the userOp.calldata with batched transaction which approves the paymaster spender with necessary amount(if required)
     * @returns updated userOp with new callData, callGasLimit
     */
    buildTokenPaymasterUserOp(userOp: Partial<UserOperation>, tokenPaymasterRequest: BiconomyTokenPaymasterRequest): Promise<Partial<UserOperation>>;
    signUserOpHash(userOpHash: string, params?: ModuleInfo): Promise<string>;
    signMessage(message: Bytes | string): Promise<string>;
    getAllTokenBalances(balancesDto: BalancesDto): Promise<BalancesResponse>;
    getTotalBalanceInUsd(balancesDto: BalancesDto): Promise<UsdBalanceResponse>;
    getSmartAccountsByOwner(smartAccountByOwnerDto: SmartAccountByOwnerDto): Promise<SmartAccountsResponse>;
    getTransactionsByAddress(chainId: number, address: string): Promise<SCWTransactionResponse[]>;
    getTransactionByHash(txHash: string): Promise<SCWTransactionResponse>;
    getAllSupportedChains(): Promise<SupportedChainsResponse>;
    getImplementationAddress(): string;
    enableModule(moduleAddress: string): Promise<UserOpResponse>;
    getEnableModuleData(moduleAddress: string): Promise<Transaction>;
    getSetupAndEnableModuleData(moduleAddress: string, moduleSetupData: string): Promise<Transaction>;
    disableModule(prevModule: string, moduleAddress: string): Promise<UserOpResponse>;
    getDisableModuleData(prevModule: string, moduleAddress: string): Promise<Transaction>;
    isModuleEnabled(moduleName: string): Promise<boolean>;
    getAllModules(pageSize?: number): Promise<Array<string>>;
}
