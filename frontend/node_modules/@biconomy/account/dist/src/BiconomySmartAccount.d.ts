import { BigNumberish, BytesLike, BigNumber } from "ethers";
import { SmartAccount } from "./SmartAccount";
import { BiconomySmartAccountConfig, Overrides, BiconomyTokenPaymasterRequest, InitilizationData } from "./utils/Types";
import { UserOperation, Transaction } from "@biconomy/core-types";
import { IBiconomySmartAccount } from "./interfaces/IBiconomySmartAccount";
import { SupportedChainsResponse, BalancesResponse, BalancesDto, UsdBalanceResponse, SmartAccountByOwnerDto, SmartAccountsResponse, SCWTransactionResponse } from "@biconomy/node-client";
import { Signer } from "ethers";
export declare class BiconomySmartAccount extends SmartAccount implements IBiconomySmartAccount {
    readonly biconomySmartAccountConfig: BiconomySmartAccountConfig;
    private factory;
    private nodeClient;
    private accountIndex;
    private address;
    private smartAccountInfo;
    private _isInitialised;
    constructor(biconomySmartAccountConfig: BiconomySmartAccountConfig);
    /**
     * @description This function will initialise BiconomyAccount class state
     * @returns Promise<BiconomyAccount>
     */
    init(initilizationData?: InitilizationData): Promise<this>;
    attachSigner(_signer: Signer): Promise<void>;
    private isInitialized;
    private setProxyContractState;
    private setEntryPointContractState;
    private setFactoryContractState;
    private setContractsState;
    initializeAccountAtIndex(accountIndex: number): Promise<void>;
    getSmartAccountAddress(accountIndex?: number): Promise<string>;
    private setInitCode;
    /**
     * @description an overrided function to showcase overriding example
     * @returns
     */
    nonce(): Promise<BigNumber>;
    /**
     *
     * @param to { target } address of transaction
     * @param value  represents amount of native tokens
     * @param data represent data associated with transaction
     * @returns
     */
    getExecuteCallData(to: string, value: BigNumberish, data: BytesLike): string;
    /**
     *
     * @param to { target } array of addresses in transaction
     * @param value  represents array of amount of native tokens associated with each transaction
     * @param data represent array of data associated with each transaction
     * @returns
     */
    getExecuteBatchCallData(to: Array<string>, value: Array<BigNumberish>, data: Array<BytesLike>): string;
    getDummySignature(): string;
    getDummyPaymasterData(): string;
    buildUserOp(transactions: Transaction[], overrides?: Overrides, skipBundlerGasEstimation?: boolean): Promise<Partial<UserOperation>>;
    private validateUserOpAndRequest;
    /**
     *
     * @param userOp partial user operation without signature and paymasterAndData
     * @param tokenPaymasterRequest This dto provides information about fee quote. Fee quote is received from earlier request getFeeQuotesOrData() to the Biconomy paymaster.
     *  maxFee and token decimals from the quote, along with the spender is required to append approval transaction.
     * @notice This method should be called when gas is paid in ERC20 token using TokenPaymaster
     * @description Optional method to update the userOp.calldata with batched transaction which approves the paymaster spender with necessary amount(if required)
     * @returns updated userOp with new callData, callGasLimit
     */
    buildTokenPaymasterUserOp(userOp: Partial<UserOperation>, tokenPaymasterRequest: BiconomyTokenPaymasterRequest): Promise<Partial<UserOperation>>;
    getAllTokenBalances(balancesDto: BalancesDto): Promise<BalancesResponse>;
    getTotalBalanceInUsd(balancesDto: BalancesDto): Promise<UsdBalanceResponse>;
    getSmartAccountsByOwner(smartAccountByOwnerDto: SmartAccountByOwnerDto): Promise<SmartAccountsResponse>;
    getTransactionsByAddress(chainId: number, address: string): Promise<SCWTransactionResponse[]>;
    getTransactionByHash(txHash: string): Promise<SCWTransactionResponse>;
    getAllSupportedChains(): Promise<SupportedChainsResponse>;
}
