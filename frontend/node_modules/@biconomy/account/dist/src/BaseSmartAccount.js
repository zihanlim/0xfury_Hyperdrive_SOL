"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseSmartAccount = void 0;
const providers_1 = require("@ethersproject/providers");
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const Preverificaiton_1 = require("./utils/Preverificaiton");
const common_1 = require("@biconomy/common");
const contracts_1 = require("@account-abstraction/contracts");
const Constants_1 = require("./utils/Constants");
class BaseSmartAccount {
    constructor(_smartAccountConfig) {
        var _a, _b, _c;
        this.index = (_a = _smartAccountConfig.index) !== null && _a !== void 0 ? _a : 0;
        this.overheads = _smartAccountConfig.overheads;
        this.entryPointAddress = (_b = _smartAccountConfig.entryPointAddress) !== null && _b !== void 0 ? _b : Constants_1.DEFAULT_ENTRYPOINT_ADDRESS;
        this.accountAddress = _smartAccountConfig.accountAddress;
        this.paymaster = _smartAccountConfig.paymaster;
        this.bundler = _smartAccountConfig.bundler;
        this.chainId = _smartAccountConfig.chainId;
        this.provider = (_c = _smartAccountConfig.provider) !== null && _c !== void 0 ? _c : new providers_1.JsonRpcProvider(common_1.RPC_PROVIDER_URLS[this.chainId]);
        // Create an instance of the EntryPoint contract using the provided address and provider (facory "connect" contract address)
        // Then, set the transaction's sender ("from" address) to the zero address (AddressZero). (contract "connect" from address)
        this.entryPoint = contracts_1.EntryPoint__factory.connect(this.entryPointAddress, this.provider).connect(ethers_1.ethers.constants.AddressZero);
    }
    async init() {
        if (this.entryPointAddress === Constants_1.DEFAULT_ENTRYPOINT_ADDRESS)
            return this;
        if ((await this.provider.getCode(this.entryPointAddress)) === "0x") {
            throw new Error(`EntryPoint not deployed at ${this.entryPointAddress} at chainId ${this.chainId}}`);
        }
        return this;
    }
    setEntryPointAddress(entryPointAddress) {
        this.entryPointAddress = entryPointAddress;
    }
    validateUserOp(userOp, requiredFields) {
        for (const field of requiredFields) {
            if (!userOp[field]) {
                throw new Error(`${field} is missing`);
            }
        }
        return true;
    }
    isProviderDefined() {
        if (!this.provider)
            throw new Error("Provider is undefined");
        return true;
    }
    /**
     * Sign the filled userOp.
     * @param userOp the UserOperation to sign (with signature field ignored)
     */
    async signUserOp(userOp) {
        const requiredFields = [
            "sender",
            "nonce",
            "initCode",
            "callData",
            "callGasLimit",
            "verificationGasLimit",
            "preVerificationGas",
            "maxFeePerGas",
            "maxPriorityFeePerGas",
            "paymasterAndData",
        ];
        this.validateUserOp(userOp, requiredFields);
        const userOpHash = await this.getUserOpHash(userOp);
        let signature = await this.signUserOpHash(userOpHash);
        // Some signers do not return signed data with 0x prefix. make sure the v value is 27/28 instead of 0/1
        // Also split sig and add +27 to v is v is only 0/1. then stitch it back
        // Note: Should only be applied for ECDSA k1 signatures
        const potentiallyIncorrectV = parseInt(signature.slice(-2), 16);
        if (![27, 28].includes(potentiallyIncorrectV)) {
            const correctV = potentiallyIncorrectV + 27;
            signature = signature.slice(0, -2) + correctV.toString(16);
        }
        if (signature.slice(0, 2) !== "0x") {
            signature = "0x" + signature;
        }
        userOp.signature = signature;
        return userOp;
    }
    /**
     *
     * @param userOp
     * @description This function call will take 'unsignedUserOp' as an input, sign it with the owner key, and send it to the bundler.
     * @returns Promise<UserOpResponse>
     */
    async sendUserOp(userOp) {
        common_1.Logger.log("userOp received in base account ", userOp);
        delete userOp.signature;
        const userOperation = await this.signUserOp(userOp);
        const bundlerResponse = await this.sendSignedUserOp(userOperation);
        return bundlerResponse;
    }
    /**
     *
     * @param userOp
     * @description This function call will take 'signedUserOp' as input and send it to the bundler
     * @returns
     */
    async sendSignedUserOp(userOp) {
        const requiredFields = [
            "sender",
            "nonce",
            "initCode",
            "callData",
            "callGasLimit",
            "verificationGasLimit",
            "preVerificationGas",
            "maxFeePerGas",
            "maxPriorityFeePerGas",
            "paymasterAndData",
            "signature",
        ];
        this.validateUserOp(userOp, requiredFields);
        common_1.Logger.log("userOp validated");
        if (!this.bundler)
            throw new Error("Bundler is not provided");
        common_1.Logger.log("userOp being sent to the bundler", userOp);
        const bundlerResponse = await this.bundler.sendUserOp(userOp);
        return bundlerResponse;
    }
    async calculateUserOpGasValues(userOp) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if (!this.provider)
            throw new Error("Provider is not present for making rpc calls");
        const feeData = await this.provider.getFeeData();
        userOp.maxFeePerGas = (_c = (_b = (_a = userOp.maxFeePerGas) !== null && _a !== void 0 ? _a : feeData.maxFeePerGas) !== null && _b !== void 0 ? _b : feeData.gasPrice) !== null && _c !== void 0 ? _c : (await this.provider.getGasPrice());
        userOp.maxPriorityFeePerGas =
            (_f = (_e = (_d = userOp.maxPriorityFeePerGas) !== null && _d !== void 0 ? _d : feeData.maxPriorityFeePerGas) !== null && _e !== void 0 ? _e : feeData.gasPrice) !== null && _f !== void 0 ? _f : (await this.provider.getGasPrice());
        if (userOp.initCode)
            userOp.verificationGasLimit = (_g = userOp.verificationGasLimit) !== null && _g !== void 0 ? _g : (await this.getVerificationGasLimit(userOp.initCode));
        userOp.callGasLimit =
            (_h = userOp.callGasLimit) !== null && _h !== void 0 ? _h : (await this.provider.estimateGas({
                from: this.entryPointAddress,
                to: userOp.sender,
                data: userOp.callData,
            }));
        userOp.preVerificationGas = (_j = userOp.preVerificationGas) !== null && _j !== void 0 ? _j : (await this.getPreVerificationGas(userOp));
        return userOp;
    }
    async estimateUserOpGas(userOp, overrides, skipBundlerGasEstimation) {
        var _a, _b, _c, _d;
        const requiredFields = ["sender", "nonce", "initCode", "callData"];
        this.validateUserOp(userOp, requiredFields);
        let finalUserOp = userOp;
        const skipBundlerCall = skipBundlerGasEstimation !== null && skipBundlerGasEstimation !== void 0 ? skipBundlerGasEstimation : false;
        // Override gas values in userOp if provided in overrides params
        if (overrides) {
            userOp = { ...userOp, ...overrides };
        }
        common_1.Logger.log("userOp in estimation", userOp);
        if (!this.bundler || skipBundlerCall) {
            if (!this.provider)
                throw new Error("Provider is not present for making rpc calls");
            // if no bundler url is provided run offchain logic to assign following values of UserOp
            // maxFeePerGas, maxPriorityFeePerGas, verificationGasLimit, callGasLimit, preVerificationGas
            finalUserOp = await this.calculateUserOpGasValues(userOp);
        }
        else {
            delete userOp.maxFeePerGas;
            delete userOp.maxPriorityFeePerGas;
            // Making call to bundler to get gas estimations for userOp
            const { callGasLimit, verificationGasLimit, preVerificationGas, maxFeePerGas, maxPriorityFeePerGas } = await this.bundler.estimateUserOpGas(userOp);
            // if neither user sent gas fee nor the bundler, estimate gas from provider
            if (!userOp.maxFeePerGas && !userOp.maxPriorityFeePerGas && (!maxFeePerGas || !maxPriorityFeePerGas)) {
                const feeData = await this.provider.getFeeData();
                finalUserOp.maxFeePerGas = (_b = (_a = feeData.maxFeePerGas) !== null && _a !== void 0 ? _a : feeData.gasPrice) !== null && _b !== void 0 ? _b : (await this.provider.getGasPrice());
                finalUserOp.maxPriorityFeePerGas = (_d = (_c = feeData.maxPriorityFeePerGas) !== null && _c !== void 0 ? _c : feeData.gasPrice) !== null && _d !== void 0 ? _d : (await this.provider.getGasPrice());
            }
            else {
                finalUserOp.maxFeePerGas = maxFeePerGas !== null && maxFeePerGas !== void 0 ? maxFeePerGas : userOp.maxFeePerGas;
                finalUserOp.maxPriorityFeePerGas = maxPriorityFeePerGas !== null && maxPriorityFeePerGas !== void 0 ? maxPriorityFeePerGas : userOp.maxPriorityFeePerGas;
            }
            finalUserOp.verificationGasLimit = verificationGasLimit !== null && verificationGasLimit !== void 0 ? verificationGasLimit : userOp.verificationGasLimit;
            finalUserOp.callGasLimit = callGasLimit !== null && callGasLimit !== void 0 ? callGasLimit : userOp.callGasLimit;
            finalUserOp.preVerificationGas = preVerificationGas !== null && preVerificationGas !== void 0 ? preVerificationGas : userOp.preVerificationGas;
        }
        return finalUserOp;
    }
    // Would only be used if paymaster is attached
    async getPaymasterAndData(userOp) {
        if (this.paymaster) {
            const paymasterAndDataResponse = await this.paymaster.getPaymasterAndData(userOp);
            return paymasterAndDataResponse.paymasterAndData;
        }
        return "0x";
    }
    async isAccountDeployed(address) {
        this.isProviderDefined();
        let isDeployed = false;
        const contractCode = await this.provider.getCode(address);
        if (contractCode.length > 2) {
            isDeployed = true;
        }
        else {
            isDeployed = false;
        }
        return isDeployed;
    }
    /**
     * calculate the account address even before it is deployed
     */
    async getCounterFactualAddress() {
        const initCode = this.getAccountInitCode();
        // use entryPoint to query account address (factory can provide a helper method to do the same, but
        // this method attempts to be generic
        try {
            await this.entryPoint.callStatic.getSenderAddress(initCode);
        }
        catch (e) {
            if (e.errorArgs == null) {
                throw e;
            }
            return e.errorArgs.sender;
        }
        throw new Error("must handle revert");
    }
    /**
     * return initCode value to into the UserOp.
     * (either deployment code, or empty hex if contract already deployed)
     */
    async getInitCode() {
        if (await this.isAccountDeployed(await this.getAccountAddress())) {
            return "0x";
        }
        return this.getAccountInitCode();
    }
    async getPreVerificationGas(userOp) {
        return (0, Preverificaiton_1.calcPreVerificationGas)(userOp);
    }
    async getVerificationGasLimit(initCode) {
        // Verification gas should be max(initGas(wallet deployment) + validateUserOp + validatePaymasterUserOp , postOp)
        const initGas = await this.estimateCreationGas(initCode);
        const validateUserOpGas = ethers_1.BigNumber.from(Preverificaiton_1.DefaultGasLimits.validatePaymasterUserOpGas + Preverificaiton_1.DefaultGasLimits.validateUserOpGas);
        const postOpGas = ethers_1.BigNumber.from(Preverificaiton_1.DefaultGasLimits.postOpGas);
        let verificationGasLimit = ethers_1.BigNumber.from(validateUserOpGas).add(initGas);
        if (ethers_1.BigNumber.from(postOpGas).gt(verificationGasLimit)) {
            verificationGasLimit = postOpGas;
        }
        return verificationGasLimit;
    }
    /**
     * return the account's address.
     * this value is valid even before deploying the contract.
     */
    async getAccountAddress() {
        if (this.accountAddress == null) {
            // means it needs deployment
            this.accountAddress = await this.getCounterFactualAddress();
        }
        return this.accountAddress;
    }
    async estimateCreationGas(initCode) {
        if (initCode == null || initCode === "0x")
            return 0;
        const deployerAddress = initCode.substring(0, 42);
        const deployerCallData = "0x" + initCode.substring(42);
        return this.provider.estimateGas({ to: deployerAddress, data: deployerCallData });
    }
    /**
     * get the transaction that has this userOpHash mined, or null if not found
     * @param userOpHash returned by sendUserOpToBundler (or by getUserOpHash..)
     * @param timeout stop waiting after this timeout
     * @param interval time to wait between polls.
     * @return the transactionHash this userOp was mined, or null if not found.
     */
    async getUserOpReceipt(userOpHash, timeout = 30000, interval = 5000) {
        const endtime = Date.now() + timeout;
        while (Date.now() < endtime) {
            const events = await this.entryPoint.queryFilter(this.entryPoint.filters.UserOperationEvent(userOpHash));
            if (events.length > 0) {
                return events[0].transactionHash;
            }
            await new Promise((resolve) => setTimeout(resolve, interval));
        }
        return null;
    }
    async getUserOpHash(userOp) {
        const userOpHash = (0, utils_1.keccak256)((0, common_1.packUserOp)(userOp, true));
        const enc = utils_1.defaultAbiCoder.encode(["bytes32", "address", "uint256"], [userOpHash, this.entryPoint.address, this.chainId]);
        return (0, utils_1.keccak256)(enc);
    }
    /**
     * ABI-encode a user operation. used for calldata cost estimation
     */
    packUserOp(userOp) {
        return (0, common_1.packUserOp)(userOp, false);
    }
    async encodeUserOpCallDataAndGasLimit(detailsForUserOp) {
        var _a, _b;
        function parseNumber(a) {
            if (a == null || a === "")
                return null;
            return ethers_1.BigNumber.from(a.toString());
        }
        const value = (_a = parseNumber(detailsForUserOp.value)) !== null && _a !== void 0 ? _a : ethers_1.BigNumber.from(0);
        const callData = await this.encodeExecute(detailsForUserOp.target, value, detailsForUserOp.data);
        const callGasLimit = (_b = parseNumber(detailsForUserOp.gasLimit)) !== null && _b !== void 0 ? _b : (await this.provider.estimateGas({
            from: this.entryPointAddress,
            to: this.getAccountAddress(),
            data: callData,
        }));
        return {
            callData,
            callGasLimit,
        };
    }
    /**
     * helper method: create and sign a user operation.
     * @param info transaction details for the userOp
     */
    async createSignedUserOp(info) {
        common_1.Logger.log("createSignedUserOp called with info", info);
        throw new Error("Not implemented. Please use buildUserOp/buildUserOperation in account implementation");
    }
}
exports.BaseSmartAccount = BaseSmartAccount;
//# sourceMappingURL=BaseSmartAccount.js.map