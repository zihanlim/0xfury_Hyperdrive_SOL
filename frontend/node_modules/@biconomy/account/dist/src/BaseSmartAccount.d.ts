import { Provider } from "@ethersproject/providers";
import { BigNumber, BigNumberish, BytesLike, Bytes } from "ethers";
import { IBaseSmartAccount } from "./interfaces/IBaseSmartAccount";
import { UserOperation, ChainId } from "@biconomy/core-types";
import { NotPromise } from "@biconomy/common";
import { IBundler, UserOpResponse } from "@biconomy/bundler";
import { IPaymaster } from "@biconomy/paymaster";
import { BaseSmartAccountConfig, Overrides, TransactionDetailsForUserOp } from "./utils/Types";
import { GasOverheads } from "./utils/Preverificaiton";
type UserOperationKey = keyof UserOperation;
export declare abstract class BaseSmartAccount implements IBaseSmartAccount {
    bundler?: IBundler;
    paymaster?: IPaymaster;
    overheads?: Partial<GasOverheads>;
    entryPointAddress: string;
    accountAddress?: string;
    index: number;
    chainId?: ChainId;
    provider: Provider;
    private readonly entryPoint;
    constructor(_smartAccountConfig: BaseSmartAccountConfig);
    init(): Promise<this>;
    setEntryPointAddress(entryPointAddress: string): void;
    validateUserOp(userOp: Partial<UserOperation>, requiredFields: UserOperationKey[]): boolean;
    isProviderDefined(): boolean;
    /**
     * return the value to put into the "initCode" field, if the contract is not yet deployed.
     * this value holds the "factory" address, followed by this account's information
     */
    abstract getAccountInitCode(): Promise<string>;
    /**
     * return current account's nonce.
     */
    abstract getNonce(): Promise<BigNumber>;
    /**
     * encode the call from entryPoint through our account to the target contract.
     * @param to
     * @param value
     * @param data
     */
    abstract encodeExecute(_to: string, _value: BigNumberish, _data: BytesLike): Promise<string>;
    /**
     * encode the batch call from entryPoint through our account to the target contract.
     * @param to
     * @param value
     * @param data
     */
    abstract encodeExecuteBatch(_to: Array<string>, _value: Array<BigNumberish>, _data: Array<BytesLike>): Promise<string>;
    /**
     * sign a userOp's hash (userOpHash).
     * @param userOpHash
     */
    abstract signUserOpHash(_userOpHash: string): Promise<string>;
    abstract signMessage(_message: Bytes | string): Promise<string>;
    /**
     * get dummy signature for userOp
     */
    abstract getDummySignature(): Promise<string>;
    /**
     * Sign the filled userOp.
     * @param userOp the UserOperation to sign (with signature field ignored)
     */
    signUserOp(userOp: Partial<UserOperation>): Promise<UserOperation>;
    /**
     *
     * @param userOp
     * @description This function call will take 'unsignedUserOp' as an input, sign it with the owner key, and send it to the bundler.
     * @returns Promise<UserOpResponse>
     */
    sendUserOp(userOp: Partial<UserOperation>): Promise<UserOpResponse>;
    /**
     *
     * @param userOp
     * @description This function call will take 'signedUserOp' as input and send it to the bundler
     * @returns
     */
    sendSignedUserOp(userOp: UserOperation): Promise<UserOpResponse>;
    calculateUserOpGasValues(userOp: Partial<UserOperation>): Promise<Partial<UserOperation>>;
    estimateUserOpGas(userOp: Partial<UserOperation>, overrides?: Overrides, skipBundlerGasEstimation?: boolean): Promise<Partial<UserOperation>>;
    getPaymasterAndData(userOp: Partial<UserOperation>): Promise<string>;
    isAccountDeployed(address: string): Promise<boolean>;
    /**
     * calculate the account address even before it is deployed
     */
    getCounterFactualAddress(): Promise<string>;
    /**
     * return initCode value to into the UserOp.
     * (either deployment code, or empty hex if contract already deployed)
     */
    getInitCode(): Promise<string>;
    getPreVerificationGas(userOp: Partial<UserOperation>): Promise<BigNumber>;
    getVerificationGasLimit(initCode: BytesLike): Promise<BigNumber>;
    /**
     * return the account's address.
     * this value is valid even before deploying the contract.
     */
    getAccountAddress(): Promise<string>;
    estimateCreationGas(initCode?: string): Promise<BigNumberish>;
    /**
     * get the transaction that has this userOpHash mined, or null if not found
     * @param userOpHash returned by sendUserOpToBundler (or by getUserOpHash..)
     * @param timeout stop waiting after this timeout
     * @param interval time to wait between polls.
     * @return the transactionHash this userOp was mined, or null if not found.
     */
    getUserOpReceipt(userOpHash: string, timeout?: number, interval?: number): Promise<string | null>;
    getUserOpHash(userOp: Partial<UserOperation>): Promise<string>;
    /**
     * ABI-encode a user operation. used for calldata cost estimation
     */
    packUserOp(userOp: NotPromise<UserOperation>): string;
    encodeUserOpCallDataAndGasLimit(detailsForUserOp: TransactionDetailsForUserOp): Promise<{
        callData: string;
        callGasLimit: BigNumber;
    }>;
    /**
     * helper method: create and sign a user operation.
     * @param info transaction details for the userOp
     */
    createSignedUserOp(info: TransactionDetailsForUserOp): Promise<UserOperation>;
}
export {};
