"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionLocalStorage = void 0;
const ethers_1 = require("ethers");
class SessionLocalStorage {
    constructor(smartAccountAddress) {
        this.smartAccountAddress = smartAccountAddress.toLowerCase();
    }
    validateSearchParam(param) {
        if (param.sessionID) {
            return;
        }
        else if (!param.sessionID && param.sessionPublicKey && param.sessionValidationModule) {
            return;
        }
        else {
            throw new Error("Either pass sessionId or a combination of sessionPublicKey and sessionValidationModule address.");
        }
    }
    getSessionStore() {
        const data = localStorage.getItem(this.getStorageKey("sessions"));
        return data ? JSON.parse(data) : { merkleRoot: "", leafNodes: [] };
    }
    getSignerStore() {
        const data = localStorage.getItem(this.getStorageKey("signers"));
        return data ? JSON.parse(data) : {};
    }
    getStorageKey(type) {
        return `${this.smartAccountAddress}_${type}`;
    }
    toLowercaseAddress(address) {
        return address.toLowerCase();
    }
    async addSessionData(leaf) {
        const data = this.getSessionStore();
        leaf.sessionValidationModule = this.toLowercaseAddress(leaf.sessionValidationModule);
        leaf.sessionPublicKey = this.toLowercaseAddress(leaf.sessionPublicKey);
        data.leafNodes.push(leaf);
        localStorage.setItem(this.getStorageKey("sessions"), JSON.stringify(data));
    }
    async getSessionData(param) {
        this.validateSearchParam(param);
        const sessions = this.getSessionStore().leafNodes;
        const session = sessions.find((s) => {
            if (param.sessionID) {
                return s.sessionID === param.sessionID && (!param.status || s.status === param.status);
            }
            else if (param.sessionPublicKey && param.sessionValidationModule) {
                return (s.sessionPublicKey === this.toLowercaseAddress(param.sessionPublicKey) &&
                    s.sessionValidationModule === this.toLowercaseAddress(param.sessionValidationModule) &&
                    (!param.status || s.status === param.status));
            }
            else {
                return undefined;
            }
        });
        if (!session) {
            throw new Error("Session not found.");
        }
        return session;
    }
    async updateSessionStatus(param, status) {
        this.validateSearchParam(param);
        const data = this.getSessionStore();
        const session = data.leafNodes.find((s) => {
            if (param.sessionID) {
                return s.sessionID === param.sessionID;
            }
            else if (param.sessionPublicKey && param.sessionValidationModule) {
                return (s.sessionPublicKey === this.toLowercaseAddress(param.sessionPublicKey) &&
                    s.sessionValidationModule === this.toLowercaseAddress(param.sessionValidationModule));
            }
            else {
                return undefined;
            }
        });
        if (!session) {
            throw new Error("Session not found.");
        }
        session.status = status;
        localStorage.setItem(this.getStorageKey("sessions"), JSON.stringify(data));
    }
    async clearPendingSessions() {
        const data = this.getSessionStore();
        data.leafNodes = data.leafNodes.filter((s) => s.status !== "PENDING");
        localStorage.setItem(this.getStorageKey("sessions"), JSON.stringify(data));
    }
    async addSigner(signer) {
        const signers = this.getSignerStore();
        if (!signer) {
            signer = ethers_1.Wallet.createRandom();
        }
        signers[this.toLowercaseAddress(signer.publicKey)] = {
            privateKey: signer.privateKey,
            publicKey: signer.publicKey,
        };
        localStorage.setItem(this.getStorageKey("signers"), JSON.stringify(signers));
        return signer;
    }
    async getSignerByKey(sessionPublicKey) {
        const signers = this.getSignerStore();
        const signerData = signers[this.toLowercaseAddress(sessionPublicKey)];
        if (!signerData) {
            throw new Error("Signer not found.");
        }
        const signer = new ethers_1.Wallet(signerData.privateKey);
        return signer;
    }
    async getSignerBySession(param) {
        const session = await this.getSessionData(param);
        return this.getSignerByKey(session.sessionPublicKey);
    }
    async getAllSessionData(param) {
        const sessions = this.getSessionStore().leafNodes;
        if (!param || !param.status) {
            return sessions;
        }
        return sessions.filter((s) => s.status === param.status);
    }
    async getMerkleRoot() {
        return this.getSessionStore().merkleRoot;
    }
    setMerkleRoot(merkleRoot) {
        const data = this.getSessionStore();
        data.merkleRoot = merkleRoot;
        localStorage.setItem(this.getStorageKey("sessions"), JSON.stringify(data));
        return Promise.resolve();
    }
}
exports.SessionLocalStorage = SessionLocalStorage;
//# sourceMappingURL=SessionLocalStorage.js.map