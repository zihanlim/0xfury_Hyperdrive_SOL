"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SmartAccountAPI = exports.DefaultGasLimits = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const BaseAccountAPI_1 = require("./BaseAccountAPI");
const BiconomyPaymasterAPI_1 = require("./BiconomyPaymasterAPI");
const utils_2 = require("ethers/lib/utils");
const calcPreVerificationGas_1 = require("./calcPreVerificationGas");
const common_1 = require("@biconomy/common");
exports.DefaultGasLimits = {
    validateUserOpGas: 100000,
    validatePaymasterUserOpGas: 100000,
    postOpGas: 10877
};
/**
 * An implementation of the BaseAccountAPI using the (biconomy) SmartAccount contract.
 * - contract deployer gets "entrypoint", "owner" addresses and "index" nonce
 * - owner signs requests using normal "Ethereum Signed Message" (ether's signer.signMessage())
 * - nonce method is "nonce()"
 */
class SmartAccountAPI extends BaseAccountAPI_1.BaseAccountAPI {
    /**
     * base constructor.
     * subclass SHOULD add parameters that define the owner (signer) of this wallet
     * @param provider - read-only provider for view calls
     * @param entryPointAddress - the entryPoint to send requests through (used to calculate the request-id, and for gas estimations)
     * @param walletAddress optional wallet address, if connecting to an existing contract.
     * @param owner the signer object for the wallet owner
     * @param factoryAddress address of contract "factory" to deploy new contracts
     * @param index nonce value used when creating multiple wallets for the same owner
     */
    constructor(httpRpcClient, provider, entryPoint, clientConfig, accountAddress, implementationAddress, owner, handlerAddress, factoryAddress, index = 0, overheads) {
        super(provider, entryPoint, clientConfig, accountAddress, overheads);
        this.httpRpcClient = httpRpcClient;
        this.entryPoint = entryPoint;
        this.clientConfig = clientConfig;
        this.implementationAddress = implementationAddress;
        this.owner = owner;
        this.handlerAddress = handlerAddress;
        this.factoryAddress = factoryAddress;
        this.index = index;
        if (!clientConfig.dappAPIKey || clientConfig.dappAPIKey === '') {
            this.paymasterAPI = undefined;
        }
        else if (clientConfig.customPaymasterAPI) {
            this.paymasterAPI = clientConfig.customPaymasterAPI;
        }
        else {
            this.paymasterAPI = new BiconomyPaymasterAPI_1.BiconomyPaymasterAPI({
                signingServiceUrl: clientConfig.biconomySigningServiceUrl,
                dappAPIKey: clientConfig.dappAPIKey,
                strictSponsorshipMode: clientConfig.strictSponsorshipMode
                    ? clientConfig.strictSponsorshipMode
                    : false
            });
        }
    }
    /**
     * return the value to put into the "initCode" field, if the wallet is not yet deployed.
     * this value holds the "factory" address, followed by this wallet's information
     */
    async getAccountInitCode() {
        const deployWalletCallData = await (0, common_1.deployCounterFactualEncodedData)({
            chainId: (await this.provider.getNetwork()).chainId,
            owner: await this.owner.getAddress(),
            txServiceUrl: this.clientConfig.txServiceUrl,
            index: this.index
        });
        return (0, utils_1.hexConcat)([this.factoryAddress, deployWalletCallData]);
    }
    async nonce() {
        common_1.Logger.log('checking nonce');
        if (!(await this.checkAccountDeployed())) {
            return ethers_1.BigNumber.from(0);
        }
        const walletContract = await this._getSmartAccountContract();
        const nonce = await walletContract.nonce();
        return nonce;
    }
    /**
     * should cover cost of putting calldata on-chain, and some overhead.
     * actual overhead depends on the expected bundle size
     */
    async getPreVerificationGas(userOp) {
        const p = await (0, utils_2.resolveProperties)(userOp);
        return (0, calcPreVerificationGas_1.calcPreVerificationGas)(p, this.overheads);
    }
    /**
     * return maximum gas used for verification.
     * NOTE: createUnsignedUserOp will add to this value the cost of creation, if the contract is not yet created.
     */
    async getVerificationGasLimit() {
        // Verification gas should be max(initGas(wallet deployment) + validateUserOp + validatePaymasterUserOp , postOp)
        const initCode = await this.getInitCode();
        const initGas = await this.estimateCreationGas(initCode);
        console.log('initgas estimated is ', initGas);
        let verificationGasLimit = initGas;
        const validateUserOpGas = exports.DefaultGasLimits.validatePaymasterUserOpGas + exports.DefaultGasLimits.validateUserOpGas;
        const postOpGas = exports.DefaultGasLimits.postOpGas;
        verificationGasLimit = ethers_1.BigNumber.from(validateUserOpGas).add(initGas);
        if (ethers_1.BigNumber.from(postOpGas).gt(verificationGasLimit)) {
            verificationGasLimit = postOpGas;
        }
        return verificationGasLimit;
    }
    async encodeExecuteCall(target, value, data) {
        const walletContract = await this._getSmartAccountContract();
        return walletContract.interface.encodeFunctionData('executeCall', [target, value, data]);
    }
    async encodeExecuteBatchCall(target, value, data) {
        const walletContract = await this._getSmartAccountContract();
        const encodeData = walletContract.interface.encodeFunctionData('executeBatchCall', [
            target,
            value,
            data
        ]);
        common_1.Logger.log('encodeData ', encodeData);
        return encodeData;
    }
    /**
     * create a UserOperation, filling all details (except signature)
     * - if wallet is not yet created, add initCode to deploy it.
     * - if gas or nonce are missing, read them from the chain (note that we can't fill gaslimit before the wallet is created)
     * @param info
     */
    async createUnsignedUserOp(info) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const { callData, callGasLimit } = await this.encodeUserOpCallDataAndGasLimit(info);
        console.log(callData, callGasLimit);
        const initCode = await this.getInitCode();
        /* eslint-disable  @typescript-eslint/no-explicit-any */
        const partialUserOp = {
            sender: await this.getAccountAddress(),
            nonce: (await this.nonce()).toHexString(),
            initCode,
            callData,
            paymasterAndData: '0x'
        };
        let { maxFeePerGas, maxPriorityFeePerGas } = info;
        const chainId = this.clientConfig.chainId;
        if (common_1.EIP1559_UNSUPPORTED_NETWORKS.includes(chainId) && (maxFeePerGas || maxPriorityFeePerGas)) {
            throw new Error('EIP1559 is not supported on this network');
        }
        let feeData;
        try {
            feeData = await this.httpRpcClient.getUserOpGasAndGasPrices(partialUserOp);
            // only uodate if not provided by the user
            if (maxFeePerGas == null || maxPriorityFeePerGas == null) {
                if (feeData.maxFeePerGas) {
                    // if type 2 transaction, use the gas prices from the user or the default gas price
                    maxFeePerGas = maxFeePerGas !== null && maxFeePerGas !== void 0 ? maxFeePerGas : ethers_1.BigNumber.from(feeData.maxFeePerGas);
                    maxPriorityFeePerGas =
                        maxPriorityFeePerGas !== null && maxPriorityFeePerGas !== void 0 ? maxPriorityFeePerGas : ethers_1.BigNumber.from(feeData.maxPriorityFeePerGas);
                }
                else {
                    maxFeePerGas = maxFeePerGas !== null && maxFeePerGas !== void 0 ? maxFeePerGas : ethers_1.BigNumber.from(feeData.gasPrice);
                    maxPriorityFeePerGas = maxPriorityFeePerGas !== null && maxPriorityFeePerGas !== void 0 ? maxPriorityFeePerGas : ethers_1.BigNumber.from(feeData.gasPrice);
                }
            }
        }
        catch (e) {
            common_1.Logger.log('error getting feeData', e.message);
            common_1.Logger.log('setting manual data');
            // fallback userOp update
            partialUserOp.nonce = await this.nonce();
            partialUserOp.callGasLimit = callGasLimit;
            // only fetch getFeeData if not provided by the user
            if (maxFeePerGas == null || maxPriorityFeePerGas == null) {
                const fallbackFeeData = await this.provider.getFeeData();
                common_1.Logger.log('EIP1559 fallbackFeeData', fallbackFeeData);
                if (common_1.EIP1559_UNSUPPORTED_NETWORKS.includes(chainId)) {
                    maxFeePerGas =
                        (_b = (_a = fallbackFeeData.gasPrice) !== null && _a !== void 0 ? _a : (await this.provider.getGasPrice())) !== null && _b !== void 0 ? _b : undefined;
                    maxPriorityFeePerGas =
                        (_d = (_c = fallbackFeeData.gasPrice) !== null && _c !== void 0 ? _c : (await this.provider.getGasPrice())) !== null && _d !== void 0 ? _d : undefined;
                }
                if (maxFeePerGas == null) {
                    maxFeePerGas = (_e = fallbackFeeData.maxFeePerGas) !== null && _e !== void 0 ? _e : undefined; // ethers.BigNumber.from('100000000000')
                }
                if (maxPriorityFeePerGas == null) {
                    maxPriorityFeePerGas = (_f = fallbackFeeData.maxPriorityFeePerGas) !== null && _f !== void 0 ? _f : undefined; // ethers.BigNumber.from('35000000000')
                }
            }
        }
        common_1.Logger.log('feeData', feeData);
        partialUserOp.maxFeePerGas = parseInt((maxFeePerGas === null || maxFeePerGas === void 0 ? void 0 : maxFeePerGas.toString()) || '0');
        partialUserOp.maxPriorityFeePerGas = parseInt((maxPriorityFeePerGas === null || maxPriorityFeePerGas === void 0 ? void 0 : maxPriorityFeePerGas.toString()) || '0');
        partialUserOp.callGasLimit = (_g = feeData === null || feeData === void 0 ? void 0 : feeData.callGasLimit) !== null && _g !== void 0 ? _g : callGasLimit;
        partialUserOp.verificationGasLimit =
            (_h = feeData === null || feeData === void 0 ? void 0 : feeData.verificationGasLimit) !== null && _h !== void 0 ? _h : (await this.getVerificationGasLimit());
        partialUserOp.preVerificationGas =
            (_j = feeData === null || feeData === void 0 ? void 0 : feeData.preVerificationGas) !== null && _j !== void 0 ? _j : (await this.getPreVerificationGas(partialUserOp));
        common_1.Logger.log('info.paymasterServiceData', info.paymasterServiceData);
        partialUserOp.paymasterAndData = !this.paymasterAPI
            ? '0x'
            : await this.paymasterAPI.getPaymasterAndData(partialUserOp, info.paymasterServiceData);
        return {
            ...partialUserOp,
            signature: ''
        };
    }
    async signUserOpHash(userOpHash) {
        return await this.owner.signMessage((0, utils_1.arrayify)(userOpHash));
    }
}
exports.SmartAccountAPI = SmartAccountAPI;
//# sourceMappingURL=SmartAccountAPI.js.map