"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEntryPointContract = exports.getSAFactoryContract = exports.getSAProxyContract = void 0;
const core_types_1 = require("@biconomy/core-types");
const typechain_1 = require("./typechain");
// Note: Review return types while adding new implementations
function getSAProxyContract(contractInstanceDto) {
    const { smartAccountType, version, contractAddress, provider } = contractInstanceDto;
    switch (version) {
        case "V1_0_0":
            if (smartAccountType === core_types_1.SmartAccountType.BICONOMY) {
                return typechain_1.SmartAccount_v100__factory.connect(contractAddress, provider);
            }
            break;
        case "V2_0_0":
            if (smartAccountType === core_types_1.SmartAccountType.BICONOMY) {
                return typechain_1.SmartAccount_v200__factory.connect(contractAddress, provider);
            }
            break;
        default:
            return typechain_1.SmartAccount_v200__factory.connect(contractAddress, provider);
    }
    throw new Error("Invalid version or smartAccountType provided for proxy contract instance");
}
exports.getSAProxyContract = getSAProxyContract;
function getSAFactoryContract(contractInstanceDto) {
    const { smartAccountType, version, contractAddress, provider } = contractInstanceDto;
    switch (version) {
        case "V1_0_0":
            if (smartAccountType === core_types_1.SmartAccountType.BICONOMY) {
                return typechain_1.SmartAccountFactory_v100__factory.connect(contractAddress, provider);
            }
            break;
        case "V2_0_0":
            if (smartAccountType === core_types_1.SmartAccountType.BICONOMY) {
                return typechain_1.SmartAccountFactory_v200__factory.connect(contractAddress, provider);
            }
            break;
        default:
            return typechain_1.SmartAccountFactory_v200__factory.connect(contractAddress, provider);
    }
    throw new Error("Invalid version or smartAccountType provided for factory contract instance");
}
exports.getSAFactoryContract = getSAFactoryContract;
function getEntryPointContract(contractInstanceDto) {
    const { smartAccountType, version, contractAddress, provider } = contractInstanceDto;
    switch (version) {
        case "V0_0_5":
            if (smartAccountType === core_types_1.SmartAccountType.BICONOMY) {
                return typechain_1.EntryPoint_v005__factory.connect(contractAddress, provider);
            }
            break;
        case "V0_0_6":
            if (smartAccountType === core_types_1.SmartAccountType.BICONOMY) {
                return typechain_1.EntryPoint_v006__factory.connect(contractAddress, provider);
            }
            break;
        default:
            return typechain_1.EntryPoint_v006__factory.connect(contractAddress, provider);
    }
    throw new Error("Invalid version or smartAccountType provided for entrypoint contract instance");
}
exports.getEntryPointContract = getEntryPointContract;
//# sourceMappingURL=ContractsInstances.js.map